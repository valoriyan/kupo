/* tslint:disable */
/* eslint-disable */
/**
 * playhouse-backend-2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { CreateChatMessageRequestBody } from "../types";
// @ts-ignore
import { DeletePostRequestBody } from "../types";
// @ts-ignore
import { DeleteShopItemRequestBody } from "../types";
// @ts-ignore
import { FollowUserProfileParams } from "../types";
// @ts-ignore
import { GetPageOfChatMessagesRequestBody } from "../types";
// @ts-ignore
import { GetPageOfPostFromFollowedHashtagParams } from "../types";
// @ts-ignore
import { GetPageOfPostFromFollowedUsersParams } from "../types";
// @ts-ignore
import { GetPageOfPostsPaginationParams } from "../types";
// @ts-ignore
import { GetPostsScheduledByUserParams } from "../types";
// @ts-ignore
import { GetUserProfileParams } from "../types";
// @ts-ignore
import { HTTPResponseDeniedPasswordResetResponseSuccessfulPasswordResetResponse } from "../types";
// @ts-ignore
import { HTTPResponseFailedAuthResponseSuccessfulAuthResponse } from "../types";
// @ts-ignore
import { LoginUserParams } from "../types";
// @ts-ignore
import { RegisterUserParams } from "../types";
// @ts-ignore
import { RequestPasswordResetParams } from "../types";
// @ts-ignore
import { SearchUserProfilesByUsernameParams } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDeniedGetUserProfileResponseSuccessfulGetUserProfileResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToCreateChatMessageResponseSuccessfulChatMessageCreationResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToCreatePostResponseSuccessfulPostCreationResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToCreateShopItemResponseSuccessfulShopItemCreationResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToDeletePostResponseSuccessfulPostDeletionResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToDeleteShopItemResponseSuccessfulShopItemDeletionResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToFollowUserProfileResponseSuccessfulFollowOfUserProfileResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToGetPageOfPostFromFollowedHashtagResponseSuccessfulGetPageOfPostFromFollowedHashtagResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToGetPageOfPostFromFollowedUsersResponseSuccessfulGetPageOfPostFromFollowedUsersResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToGetPostsScheduledByUserResponseSuccessfulGetPostsScheduledByUserResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToSearchUserProfilesByUsernameResponseSuccessfulSearchUserProfilesByUsernameResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfulUnfollowOfUserProfileResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToUpdatePostResponseSuccessfulPostUpdateResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToUpdateShopItemResponseSuccessfulShopItemUpdateResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedtoGetPageOfChatMessagesResponseSuccessfulGetPageOfChatMessagesResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedtoGetPageOfPostsPaginationResponseSuccessfulGetPageOfPostsPaginationResponse } from "../types";
// @ts-ignore
import { UnfollowUserProfileParams } from "../types";
// @ts-ignore
import { UpdatePostParams } from "../types";
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage: async (
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatMessageRequestBody' is not null or undefined
      assertParamExists(
        "createChatMessage",
        "createChatMessageRequestBody",
        createChatMessageRequestBody,
      );
      const localVarPath = `/chat/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatMessageRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost: async (
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mediaFiles' is not null or undefined
      assertParamExists("createPost", "mediaFiles", mediaFiles);
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createPost", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createPost", "hashtags", hashtags);
      const localVarPath = `/post/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {Array<any>} mediaFiles
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem: async (
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      mediaFiles: Array<any>,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createShopItem", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createShopItem", "hashtags", hashtags);
      // verify required parameter 'title' is not null or undefined
      assertParamExists("createShopItem", "title", title);
      // verify required parameter 'price' is not null or undefined
      assertParamExists("createShopItem", "price", price);
      // verify required parameter 'scheduledPublicationTimestamp' is not null or undefined
      assertParamExists(
        "createShopItem",
        "scheduledPublicationTimestamp",
        scheduledPublicationTimestamp,
      );
      // verify required parameter 'collaboratorUserIds' is not null or undefined
      assertParamExists("createShopItem", "collaboratorUserIds", collaboratorUserIds);
      // verify required parameter 'mediaFiles' is not null or undefined
      assertParamExists("createShopItem", "mediaFiles", mediaFiles);
      const localVarPath = `/shopitem/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }
      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost: async (
      deletePostRequestBody: DeletePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deletePostRequestBody' is not null or undefined
      assertParamExists("deletePost", "deletePostRequestBody", deletePostRequestBody);
      const localVarPath = `/post/deletePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deletePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem: async (
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteShopItemRequestBody' is not null or undefined
      assertParamExists(
        "deleteShopItem",
        "deleteShopItemRequestBody",
        deleteShopItemRequestBody,
      );
      const localVarPath = `/shopitem/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteShopItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FollowUserProfileParams} followUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser: async (
      followUserProfileParams: FollowUserProfileParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'followUserProfileParams' is not null or undefined
      assertParamExists("followUser", "followUserProfileParams", followUserProfileParams);
      const localVarPath = `/userInteractions/FollowUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followUserProfileParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages: async (
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfChatMessagesRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfChatMessages",
        "getPageOfChatMessagesRequestBody",
        getPageOfChatMessagesRequestBody,
      );
      const localVarPath = `/chat/getPage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfChatMessagesRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagParams} getPageOfPostFromFollowedHashtagParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedHashtag: async (
      getPageOfPostFromFollowedHashtagParams: GetPageOfPostFromFollowedHashtagParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfPostFromFollowedHashtagParams' is not null or undefined
      assertParamExists(
        "getPageOfPostFromFollowedHashtag",
        "getPageOfPostFromFollowedHashtagParams",
        getPageOfPostFromFollowedHashtagParams,
      );
      const localVarPath = `/feed/getPageOfPostFromFollowedHashtag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfPostFromFollowedHashtagParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersParams} getPageOfPostFromFollowedUsersParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedUsers: async (
      getPageOfPostFromFollowedUsersParams: GetPageOfPostFromFollowedUsersParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfPostFromFollowedUsersParams' is not null or undefined
      assertParamExists(
        "getPageOfPostFromFollowedUsers",
        "getPageOfPostFromFollowedUsersParams",
        getPageOfPostFromFollowedUsersParams,
      );
      const localVarPath = `/feed/getPageOfPostFromFollowedUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfPostFromFollowedUsersParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfPostsPaginationParams} getPageOfPostsPaginationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostsPagination: async (
      getPageOfPostsPaginationParams: GetPageOfPostsPaginationParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfPostsPaginationParams' is not null or undefined
      assertParamExists(
        "getPageOfPostsPagination",
        "getPageOfPostsPaginationParams",
        getPageOfPostsPaginationParams,
      );
      const localVarPath = `/post/getPageOfPostsPagination`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfPostsPaginationParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPostsScheduledByUserParams} getPostsScheduledByUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser: async (
      getPostsScheduledByUserParams: GetPostsScheduledByUserParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPostsScheduledByUserParams' is not null or undefined
      assertParamExists(
        "getPostsScheduledByUser",
        "getPostsScheduledByUserParams",
        getPostsScheduledByUserParams,
      );
      const localVarPath = `/post/getPostsScheduledByUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPostsScheduledByUserParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUserProfileParams} getUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile: async (
      getUserProfileParams: GetUserProfileParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUserProfileParams' is not null or undefined
      assertParamExists("getUserProfile", "getUserProfileParams", getUserProfileParams);
      const localVarPath = `/user/GetUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUserProfileParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginUserParams} loginUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: async (
      loginUserParams: LoginUserParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginUserParams' is not null or undefined
      assertParamExists("loginUser", "loginUserParams", loginUserParams);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginUserParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh-access-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RegisterUserParams} registerUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      registerUserParams: RegisterUserParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerUserParams' is not null or undefined
      assertParamExists("registerUser", "registerUserParams", registerUserParams);
      const localVarPath = `/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerUserParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RequestPasswordResetParams} requestPasswordResetParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasswordReset: async (
      requestPasswordResetParams: RequestPasswordResetParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'requestPasswordResetParams' is not null or undefined
      assertParamExists(
        "requestPasswordReset",
        "requestPasswordResetParams",
        requestPasswordResetParams,
      );
      const localVarPath = `/auth/resetPassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestPasswordResetParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameParams} searchUserProfilesByUsernameParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername: async (
      searchUserProfilesByUsernameParams: SearchUserProfilesByUsernameParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchUserProfilesByUsernameParams' is not null or undefined
      assertParamExists(
        "searchUserProfilesByUsername",
        "searchUserProfilesByUsernameParams",
        searchUserProfilesByUsernameParams,
      );
      const localVarPath = `/user/SearchUserProfilesByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchUserProfilesByUsernameParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UnfollowUserProfileParams} unfollowUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser: async (
      unfollowUserProfileParams: UnfollowUserProfileParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unfollowUserProfileParams' is not null or undefined
      assertParamExists(
        "unfollowUser",
        "unfollowUserProfileParams",
        unfollowUserProfileParams,
      );
      const localVarPath = `/userInteractions/UnfollowUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unfollowUserProfileParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePostParams} updatePostParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost: async (
      updatePostParams: UpdatePostParams,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePostParams' is not null or undefined
      assertParamExists("updatePost", "updatePostParams", updatePostParams);
      const localVarPath = `/post/updatePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePostParams,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} shopItemId
     * @param {string} [caption]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem: async (
      shopItemId: string,
      caption?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'shopItemId' is not null or undefined
      assertParamExists("updateShopItem", "shopItemId", shopItemId);
      const localVarPath = `/shopitem/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (shopItemId !== undefined) {
        localVarFormParams.append("shopItemId", shopItemId as any);
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }
      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage: async (
      backgroundImage: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'backgroundImage' is not null or undefined
      assertParamExists("updateUserBackgroundImage", "backgroundImage", backgroundImage);
      const localVarPath = `/user/UpdateUserBackgroundImage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (backgroundImage !== undefined) {
        localVarFormParams.append("backgroundImage", backgroundImage as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [username]
     * @param {string} [shortBio]
     * @param {string} [userWebsite]
     * @param {string} [profileVisibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile: async (
      username?: string,
      shortBio?: string,
      userWebsite?: string,
      profileVisibility?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/UpdateUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (username !== undefined) {
        localVarFormParams.append("username", username as any);
      }

      if (shortBio !== undefined) {
        localVarFormParams.append("shortBio", shortBio as any);
      }

      if (userWebsite !== undefined) {
        localVarFormParams.append("userWebsite", userWebsite as any);
      }

      if (profileVisibility !== undefined) {
        localVarFormParams.append("profileVisibility", profileVisibility as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture: async (
      profilePicture: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'profilePicture' is not null or undefined
      assertParamExists("updateUserProfilePicture", "profilePicture", profilePicture);
      const localVarPath = `/user/UpdateUserProfilePicture`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (profilePicture !== undefined) {
        localVarFormParams.append("profilePicture", profilePicture as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToCreateChatMessageResponseSuccessfulChatMessageCreationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChatMessage(
        createChatMessageRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToCreatePostResponseSuccessfulPostCreationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {Array<any>} mediaFiles
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShopItem(
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      mediaFiles: Array<any>,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToCreateShopItemResponseSuccessfulShopItemCreationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShopItem(
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToDeletePostResponseSuccessfulPostDeletionResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(
        deletePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToDeleteShopItemResponseSuccessfulShopItemDeletionResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShopItem(
        deleteShopItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {FollowUserProfileParams} followUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async followUser(
      followUserProfileParams: FollowUserProfileParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToFollowUserProfileResponseSuccessfulFollowOfUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(
        followUserProfileParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedtoGetPageOfChatMessagesResponseSuccessfulGetPageOfChatMessagesResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfChatMessages(
        getPageOfChatMessagesRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagParams} getPageOfPostFromFollowedHashtagParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfPostFromFollowedHashtag(
      getPageOfPostFromFollowedHashtagParams: GetPageOfPostFromFollowedHashtagParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToGetPageOfPostFromFollowedHashtagResponseSuccessfulGetPageOfPostFromFollowedHashtagResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfPostFromFollowedHashtag(
          getPageOfPostFromFollowedHashtagParams,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersParams} getPageOfPostFromFollowedUsersParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfPostFromFollowedUsers(
      getPageOfPostFromFollowedUsersParams: GetPageOfPostFromFollowedUsersParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToGetPageOfPostFromFollowedUsersResponseSuccessfulGetPageOfPostFromFollowedUsersResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfPostFromFollowedUsers(
          getPageOfPostFromFollowedUsersParams,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfPostsPaginationParams} getPageOfPostsPaginationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfPostsPagination(
      getPageOfPostsPaginationParams: GetPageOfPostsPaginationParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedtoGetPageOfPostsPaginationResponseSuccessfulGetPageOfPostsPaginationResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfPostsPagination(
        getPageOfPostsPaginationParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPostsScheduledByUserParams} getPostsScheduledByUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostsScheduledByUser(
      getPostsScheduledByUserParams: GetPostsScheduledByUserParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToGetPostsScheduledByUserResponseSuccessfulGetPostsScheduledByUserResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsScheduledByUser(
        getPostsScheduledByUserParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUserProfileParams} getUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserProfile(
      getUserProfileParams: GetUserProfileParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDeniedGetUserProfileResponseSuccessfulGetUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(
        getUserProfileParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {LoginUserParams} loginUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUser(
      loginUserParams: LoginUserParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(
        loginUserParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshAccessToken(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RegisterUserParams} registerUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      registerUserParams: RegisterUserParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        registerUserParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RequestPasswordResetParams} requestPasswordResetParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestPasswordReset(
      requestPasswordResetParams: RequestPasswordResetParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseDeniedPasswordResetResponseSuccessfulPasswordResetResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordReset(
        requestPasswordResetParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameParams} searchUserProfilesByUsernameParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchUserProfilesByUsername(
      searchUserProfilesByUsernameParams: SearchUserProfilesByUsernameParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToSearchUserProfilesByUsernameResponseSuccessfulSearchUserProfilesByUsernameResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchUserProfilesByUsername(
          searchUserProfilesByUsernameParams,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UnfollowUserProfileParams} unfollowUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfollowUser(
      unfollowUserProfileParams: UnfollowUserProfileParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfulUnfollowOfUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(
        unfollowUserProfileParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePostParams} updatePostParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePost(
      updatePostParams: UpdatePostParams,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUpdatePostResponseSuccessfulPostUpdateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(
        updatePostParams,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} shopItemId
     * @param {string} [caption]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShopItem(
      shopItemId: string,
      caption?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUpdateShopItemResponseSuccessfulShopItemUpdateResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateShopItem(
        shopItemId,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBackgroundImage(
        backgroundImage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} [username]
     * @param {string} [shortBio]
     * @param {string} [userWebsite]
     * @param {string} [profileVisibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfile(
      username?: string,
      shortBio?: string,
      userWebsite?: string,
      profileVisibility?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(
        username,
        shortBio,
        userWebsite,
        profileVisibility,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfilePicture(
        profilePicture,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToCreateChatMessageResponseSuccessfulChatMessageCreationResponse> {
      return localVarFp
        .createChatMessage(createChatMessageRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToCreatePostResponseSuccessfulPostCreationResponse> {
      return localVarFp
        .createPost(
          mediaFiles,
          caption,
          hashtags,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {Array<any>} mediaFiles
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem(
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      mediaFiles: Array<any>,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToCreateShopItemResponseSuccessfulShopItemCreationResponse> {
      return localVarFp
        .createShopItem(
          caption,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          collaboratorUserIds,
          mediaFiles,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToDeletePostResponseSuccessfulPostDeletionResponse> {
      return localVarFp
        .deletePost(deletePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToDeleteShopItemResponseSuccessfulShopItemDeletionResponse> {
      return localVarFp
        .deleteShopItem(deleteShopItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {FollowUserProfileParams} followUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser(
      followUserProfileParams: FollowUserProfileParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToFollowUserProfileResponseSuccessfulFollowOfUserProfileResponse> {
      return localVarFp
        .followUser(followUserProfileParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedtoGetPageOfChatMessagesResponseSuccessfulGetPageOfChatMessagesResponse> {
      return localVarFp
        .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagParams} getPageOfPostFromFollowedHashtagParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedHashtag(
      getPageOfPostFromFollowedHashtagParams: GetPageOfPostFromFollowedHashtagParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToGetPageOfPostFromFollowedHashtagResponseSuccessfulGetPageOfPostFromFollowedHashtagResponse> {
      return localVarFp
        .getPageOfPostFromFollowedHashtag(getPageOfPostFromFollowedHashtagParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersParams} getPageOfPostFromFollowedUsersParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedUsers(
      getPageOfPostFromFollowedUsersParams: GetPageOfPostFromFollowedUsersParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToGetPageOfPostFromFollowedUsersResponseSuccessfulGetPageOfPostFromFollowedUsersResponse> {
      return localVarFp
        .getPageOfPostFromFollowedUsers(getPageOfPostFromFollowedUsersParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfPostsPaginationParams} getPageOfPostsPaginationParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostsPagination(
      getPageOfPostsPaginationParams: GetPageOfPostsPaginationParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedtoGetPageOfPostsPaginationResponseSuccessfulGetPageOfPostsPaginationResponse> {
      return localVarFp
        .getPageOfPostsPagination(getPageOfPostsPaginationParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPostsScheduledByUserParams} getPostsScheduledByUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser(
      getPostsScheduledByUserParams: GetPostsScheduledByUserParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToGetPostsScheduledByUserResponseSuccessfulGetPostsScheduledByUserResponse> {
      return localVarFp
        .getPostsScheduledByUser(getPostsScheduledByUserParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUserProfileParams} getUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(
      getUserProfileParams: GetUserProfileParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDeniedGetUserProfileResponseSuccessfulGetUserProfileResponse> {
      return localVarFp
        .getUserProfile(getUserProfileParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {LoginUserParams} loginUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      loginUserParams: LoginUserParams,
      options?: any,
    ): AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse> {
      return localVarFp
        .loginUser(loginUserParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken(
      options?: any,
    ): AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse> {
      return localVarFp
        .refreshAccessToken(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RegisterUserParams} registerUserParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      registerUserParams: RegisterUserParams,
      options?: any,
    ): AxiosPromise<HTTPResponseFailedAuthResponseSuccessfulAuthResponse> {
      return localVarFp
        .registerUser(registerUserParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RequestPasswordResetParams} requestPasswordResetParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPasswordReset(
      requestPasswordResetParams: RequestPasswordResetParams,
      options?: any,
    ): AxiosPromise<HTTPResponseDeniedPasswordResetResponseSuccessfulPasswordResetResponse> {
      return localVarFp
        .requestPasswordReset(requestPasswordResetParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameParams} searchUserProfilesByUsernameParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername(
      searchUserProfilesByUsernameParams: SearchUserProfilesByUsernameParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToSearchUserProfilesByUsernameResponseSuccessfulSearchUserProfilesByUsernameResponse> {
      return localVarFp
        .searchUserProfilesByUsername(searchUserProfilesByUsernameParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UnfollowUserProfileParams} unfollowUserProfileParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser(
      unfollowUserProfileParams: UnfollowUserProfileParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfulUnfollowOfUserProfileResponse> {
      return localVarFp
        .unfollowUser(unfollowUserProfileParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePostParams} updatePostParams
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost(
      updatePostParams: UpdatePostParams,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUpdatePostResponseSuccessfulPostUpdateResponse> {
      return localVarFp
        .updatePost(updatePostParams, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} shopItemId
     * @param {string} [caption]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem(
      shopItemId: string,
      caption?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUpdateShopItemResponseSuccessfulShopItemUpdateResponse> {
      return localVarFp
        .updateShopItem(
          shopItemId,
          caption,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          collaboratorUserIds,
          mediaFiles,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse> {
      return localVarFp
        .updateUserBackgroundImage(backgroundImage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [username]
     * @param {string} [shortBio]
     * @param {string} [userWebsite]
     * @param {string} [profileVisibility]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile(
      username?: string,
      shortBio?: string,
      userWebsite?: string,
      profileVisibility?: string,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse> {
      return localVarFp
        .updateUserProfile(username, shortBio, userWebsite, profileVisibility, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUpdateUserProfileResponseSuccessfulUpdateToUserProfileResponse> {
      return localVarFp
        .updateUserProfilePicture(profilePicture, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChatMessage(
    createChatMessageRequestBody: CreateChatMessageRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createChatMessage(createChatMessageRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<any>} mediaFiles
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPost(
    mediaFiles: Array<any>,
    caption: string,
    hashtags: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} title
   * @param {string} price
   * @param {string} scheduledPublicationTimestamp
   * @param {string} collaboratorUserIds
   * @param {Array<any>} mediaFiles
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createShopItem(
    caption: string,
    hashtags: string,
    title: string,
    price: string,
    scheduledPublicationTimestamp: string,
    collaboratorUserIds: string,
    mediaFiles: Array<any>,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createShopItem(
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeletePostRequestBody} deletePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deletePost(deletePostRequestBody: DeletePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .deletePost(deletePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteShopItem(
    deleteShopItemRequestBody: DeleteShopItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteShopItem(deleteShopItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FollowUserProfileParams} followUserProfileParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public followUser(followUserProfileParams: FollowUserProfileParams, options?: any) {
    return DefaultApiFp(this.configuration)
      .followUser(followUserProfileParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfChatMessages(
    getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfPostFromFollowedHashtagParams} getPageOfPostFromFollowedHashtagParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfPostFromFollowedHashtag(
    getPageOfPostFromFollowedHashtagParams: GetPageOfPostFromFollowedHashtagParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfPostFromFollowedHashtag(getPageOfPostFromFollowedHashtagParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfPostFromFollowedUsersParams} getPageOfPostFromFollowedUsersParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfPostFromFollowedUsers(
    getPageOfPostFromFollowedUsersParams: GetPageOfPostFromFollowedUsersParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfPostFromFollowedUsers(getPageOfPostFromFollowedUsersParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfPostsPaginationParams} getPageOfPostsPaginationParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfPostsPagination(
    getPageOfPostsPaginationParams: GetPageOfPostsPaginationParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfPostsPagination(getPageOfPostsPaginationParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPostsScheduledByUserParams} getPostsScheduledByUserParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostsScheduledByUser(
    getPostsScheduledByUserParams: GetPostsScheduledByUserParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostsScheduledByUser(getPostsScheduledByUserParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUserProfileParams} getUserProfileParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserProfile(getUserProfileParams: GetUserProfileParams, options?: any) {
    return DefaultApiFp(this.configuration)
      .getUserProfile(getUserProfileParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginUserParams} loginUserParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public loginUser(loginUserParams: LoginUserParams, options?: any) {
    return DefaultApiFp(this.configuration)
      .loginUser(loginUserParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logout(options?: any) {
    return DefaultApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refreshAccessToken(options?: any) {
    return DefaultApiFp(this.configuration)
      .refreshAccessToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RegisterUserParams} registerUserParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerUser(registerUserParams: RegisterUserParams, options?: any) {
    return DefaultApiFp(this.configuration)
      .registerUser(registerUserParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RequestPasswordResetParams} requestPasswordResetParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public requestPasswordReset(
    requestPasswordResetParams: RequestPasswordResetParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .requestPasswordReset(requestPasswordResetParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchUserProfilesByUsernameParams} searchUserProfilesByUsernameParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchUserProfilesByUsername(
    searchUserProfilesByUsernameParams: SearchUserProfilesByUsernameParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchUserProfilesByUsername(searchUserProfilesByUsernameParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UnfollowUserProfileParams} unfollowUserProfileParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unfollowUser(
    unfollowUserProfileParams: UnfollowUserProfileParams,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .unfollowUser(unfollowUserProfileParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePostParams} updatePostParams
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePost(updatePostParams: UpdatePostParams, options?: any) {
    return DefaultApiFp(this.configuration)
      .updatePost(updatePostParams, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} shopItemId
   * @param {string} [caption]
   * @param {string} [hashtags]
   * @param {string} [title]
   * @param {string} [price]
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {string} [collaboratorUserIds]
   * @param {Array<any>} [mediaFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateShopItem(
    shopItemId: string,
    caption?: string,
    hashtags?: string,
    title?: string,
    price?: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    collaboratorUserIds?: string,
    mediaFiles?: Array<any>,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateShopItem(
        shopItemId,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} backgroundImage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserBackgroundImage(backgroundImage: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserBackgroundImage(backgroundImage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [username]
   * @param {string} [shortBio]
   * @param {string} [userWebsite]
   * @param {string} [profileVisibility]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfile(
    username?: string,
    shortBio?: string,
    userWebsite?: string,
    profileVisibility?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateUserProfile(username, shortBio, userWebsite, profileVisibility, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} profilePicture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfilePicture(profilePicture: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserProfilePicture(profilePicture, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
