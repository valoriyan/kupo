/* tslint:disable */
/* eslint-disable */
/**
 * kupono-backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { CheckResetPasswordTokenValidityRequestBody } from "../types";
// @ts-ignore
import { CommentOnPostRequestBody } from "../types";
// @ts-ignore
import { CreateChatMessageInNewRoomRequestBody } from "../types";
// @ts-ignore
import { CreateChatMessageRequestBody } from "../types";
// @ts-ignore
import { DeleteChatMessageRequestBody } from "../types";
// @ts-ignore
import { DeleteCommentFromPostRequestBody } from "../types";
// @ts-ignore
import { DeletePostRequestBody } from "../types";
// @ts-ignore
import { DeleteShopItemRequestBody } from "../types";
// @ts-ignore
import { DoesChatRoomExistWithUserIdsRequestBody } from "../types";
// @ts-ignore
import { ElevateUserToAdminRequestBody } from "../types";
// @ts-ignore
import { FollowUserRequestBody } from "../types";
// @ts-ignore
import { GetChatRoomByIdRequestBody } from "../types";
// @ts-ignore
import { GetPageOfChatMessagesRequestBody } from "../types";
// @ts-ignore
import { GetPageOfChatRoomsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfCommentsByPostIdRequestBody } from "../types";
// @ts-ignore
import { GetPageOfNotificationsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfPostFromFollowedHashtagRequestBody } from "../types";
// @ts-ignore
import { GetPageOfPostFromFollowedUsersRequestBody } from "../types";
// @ts-ignore
import { GetPageOfSavedPostsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfUsersFollowedByUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPageOfUsersFollowingUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPasswordResetEmailRequestBody } from "../types";
// @ts-ignore
import { GetPostByIdRequestBody } from "../types";
// @ts-ignore
import { GetPostsByUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPostsByUsernameRequestBody } from "../types";
// @ts-ignore
import { GetPostsScheduledByUserRequestBody } from "../types";
// @ts-ignore
import { GetShopItemsByUserIdRequestBody } from "../types";
// @ts-ignore
import { GetShopItemsByUsernameRequestBody } from "../types";
// @ts-ignore
import { GetUserProfileRequestBody } from "../types";
// @ts-ignore
import { GetUsersByIdsRequestBody } from "../types";
// @ts-ignore
import { GetUsersByUsernamesRequestBody } from "../types";
// @ts-ignore
import { HTTPResponseAuthFailedAuthSuccess } from "../types";
// @ts-ignore
import { HTTPResponseCheckResetPasswordTokenValidityFailedCheckResetPasswordTokenValiditySuccess } from "../types";
// @ts-ignore
import { HTTPResponseGetPasswordResetEmailFailedGetPasswordResetEmailSuccess } from "../types";
// @ts-ignore
import { HTTPResponseRegisterUserFailedAuthSuccess } from "../types";
// @ts-ignore
import { HTTPResponseResetPasswordFailedResetPasswordSuccess } from "../types";
// @ts-ignore
import { InlineObject5 } from "../types";
// @ts-ignore
import { InlineResponse200 } from "../types";
// @ts-ignore
import { LoginUserRequestBody } from "../types";
// @ts-ignore
import { PurchaseShopItemRequestBody } from "../types";
// @ts-ignore
import { RegisterUserRequestBody } from "../types";
// @ts-ignore
import { RemoveCreditCardRequestBody } from "../types";
// @ts-ignore
import { RemoveUserLikeFromPublishedItemRequestBody } from "../types";
// @ts-ignore
import { ResetPasswordRequestBody } from "../types";
// @ts-ignore
import { SearchForHashtagsRequestBody } from "../types";
// @ts-ignore
import { SearchForPostsRequestBody } from "../types";
// @ts-ignore
import { SearchForUsersRequestBody } from "../types";
// @ts-ignore
import { SearchUserProfilesByUsernameRequestBody } from "../types";
// @ts-ignore
import { SecuredHTTPResponseCommentOnPostFailedCommentOnPostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseCreateChatMessageFailedCreateChatMessageSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseCreateChatMessageInNewChatRoomFailedCreateChatMessageInNewChatRoomSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseCreatePostFailedCreatePostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseCreateShopItemFailedCreateShopItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDeleteChatMessageFailedDeleteChatMessageSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDeleteCommentFromPostFailedDeleteCommentFromPostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDeletePostFailedDeletePostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDeleteShopItemFailedDeleteShopItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseDoesChatRoomExistWithUserIdsFailedDoesChatRoomExistWithUserIdsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseElevateUserToAdminFailedElevateUserToAdminSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse } from "../types";
// @ts-ignore
import { SecuredHTTPResponseFollowUserFailedFollowUserSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetChatRoomByIdFailedGetChatRoomByIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetCountOfUnreadNotificationsFailedGetCountOfUnreadNotificationsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetCreditCardsStoredByUserIdFailedGetCreditCardsStoredByUserIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfChatMessagesFailedGetPageOfChatMessagesSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfChatRoomsFailedGetPageOfChatRoomsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfCommentsByPostIdFailureGetPageOfCommentsByPostIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfNotificationsFailedGetPageOfNotificationsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfPostFromFollowedHashtagFailedGetPageOfPostFromFollowedHashtagSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfPostFromFollowedUsersFailedGetPageOfPostFromFollowedUsersSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfSavedPostsFailedGetPageOfSavedPostsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfUsersFollowedByUserIdFailedGetPageOfUsersFollowedByUserIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPageOfUsersFollowingUserIdFailedGetPageOfUsersFollowingUserIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPostByIdFailedGetPostByIdSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPostsByUsernameFailedGetPostsByUsernameSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetPostsScheduledByUserFailedGetPostsScheduledByUserSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetShopItemsByUsernameFailedGetShopItemsByUsernameSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetUserContentFeedFiltersFailedGetUserContentFeedFiltersSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetUserProfileFailedGetUserProfileSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetUsersByIdsFailedGetUsersByIdsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseGetUsersByUsernamesFailedGetUsersByUsernamesSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponsePurchaseShopItemFailedPurchaseShopItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseRemoveCreditCardFailedRemoveCreditCardSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSearchForHashtagsFailedSearchForHashtagsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSearchForPostsFailedSearchForPostsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSearchForUsersFailedSearchForUsersSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSearchUserProfilesByUsernameFailedSearchUserProfilesByUsernameSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSetUserHashtagsFailedSetUserHashtagsSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseSharePostFailedSharePostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdatePasswordFailedUpdatePasswordSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdatePostFailedUpdatePostSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdateShopItemFailedUpdateShopItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdateUserBackgroundImageFailedUpdateUserBackgroundImageSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdateUserProfileFailedUpdateUserProfileSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUpdateUserProfilePictureFailedUpdateUserProfilePictureSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUserLikesPublishedItemFailedUserLikesPublishedItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUserSavesPublishedItemFailedUserSavesPublishedItemSuccess } from "../types";
// @ts-ignore
import { SecuredHTTPResponseUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess } from "../types";
// @ts-ignore
import { SetUserContentFeedFiltersRequestBody } from "../types";
// @ts-ignore
import { SetUserHashtagsRequestBody } from "../types";
// @ts-ignore
import { SharePostRequestBody } from "../types";
// @ts-ignore
import { UnfollowUserRequestBody } from "../types";
// @ts-ignore
import { UpdatePasswordRequestBody } from "../types";
// @ts-ignore
import { UpdatePostRequestBody } from "../types";
// @ts-ignore
import { UpdateUserProfileRequestBody } from "../types";
// @ts-ignore
import { UserLikesPublishedItemRequestBody } from "../types";
// @ts-ignore
import { UserSavesPublishedItemRequestBody } from "../types";
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenValidity: async (
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'checkResetPasswordTokenValidityRequestBody' is not null or undefined
      assertParamExists(
        "checkResetPasswordTokenValidity",
        "checkResetPasswordTokenValidityRequestBody",
        checkResetPasswordTokenValidityRequestBody,
      );
      const localVarPath = `/auth/checkResetPasswordTokenValidity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkResetPasswordTokenValidityRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CommentOnPostRequestBody} commentOnPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentOnPost: async (
      commentOnPostRequestBody: CommentOnPostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'commentOnPostRequestBody' is not null or undefined
      assertParamExists(
        "commentOnPost",
        "commentOnPostRequestBody",
        commentOnPostRequestBody,
      );
      const localVarPath = `/PostComment/commentOnPost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commentOnPostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage: async (
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatMessageRequestBody' is not null or undefined
      assertParamExists(
        "createChatMessage",
        "createChatMessageRequestBody",
        createChatMessageRequestBody,
      );
      const localVarPath = `/chat/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatMessageRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessageInNewChatRoom: async (
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatMessageInNewRoomRequestBody' is not null or undefined
      assertParamExists(
        "createChatMessageInNewChatRoom",
        "createChatMessageInNewRoomRequestBody",
        createChatMessageInNewRoomRequestBody,
      );
      const localVarPath = `/chat/createChatMessageInNewChatRoom`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatMessageInNewRoomRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost: async (
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mediaFiles' is not null or undefined
      assertParamExists("createPost", "mediaFiles", mediaFiles);
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createPost", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createPost", "hashtags", hashtags);
      const localVarPath = `/post/createPost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem: async (
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mediaFiles' is not null or undefined
      assertParamExists("createShopItem", "mediaFiles", mediaFiles);
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createShopItem", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createShopItem", "hashtags", hashtags);
      // verify required parameter 'title' is not null or undefined
      assertParamExists("createShopItem", "title", title);
      // verify required parameter 'price' is not null or undefined
      assertParamExists("createShopItem", "price", price);
      // verify required parameter 'scheduledPublicationTimestamp' is not null or undefined
      assertParamExists(
        "createShopItem",
        "scheduledPublicationTimestamp",
        scheduledPublicationTimestamp,
      );
      // verify required parameter 'collaboratorUserIds' is not null or undefined
      assertParamExists("createShopItem", "collaboratorUserIds", collaboratorUserIds);
      const localVarPath = `/shopitem/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessage: async (
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteChatMessageRequestBody' is not null or undefined
      assertParamExists(
        "deleteChatMessage",
        "deleteChatMessageRequestBody",
        deleteChatMessageRequestBody,
      );
      const localVarPath = `/chat/deleteChatMessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteChatMessageRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteCommentFromPostRequestBody} deleteCommentFromPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommentFromPost: async (
      deleteCommentFromPostRequestBody: DeleteCommentFromPostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteCommentFromPostRequestBody' is not null or undefined
      assertParamExists(
        "deleteCommentFromPost",
        "deleteCommentFromPostRequestBody",
        deleteCommentFromPostRequestBody,
      );
      const localVarPath = `/PostComment/deleteCommentFromPost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteCommentFromPostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost: async (
      deletePostRequestBody: DeletePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deletePostRequestBody' is not null or undefined
      assertParamExists("deletePost", "deletePostRequestBody", deletePostRequestBody);
      const localVarPath = `/post/deletePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deletePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem: async (
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteShopItemRequestBody' is not null or undefined
      assertParamExists(
        "deleteShopItem",
        "deleteShopItemRequestBody",
        deleteShopItemRequestBody,
      );
      const localVarPath = `/shopitem/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteShopItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesChatRoomExistWithUserIds: async (
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doesChatRoomExistWithUserIdsRequestBody' is not null or undefined
      assertParamExists(
        "doesChatRoomExistWithUserIds",
        "doesChatRoomExistWithUserIdsRequestBody",
        doesChatRoomExistWithUserIdsRequestBody,
      );
      const localVarPath = `/chat/doesChatRoomExistWithUserIds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doesChatRoomExistWithUserIdsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elevateUserToAdmin: async (
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'elevateUserToAdminRequestBody' is not null or undefined
      assertParamExists(
        "elevateUserToAdmin",
        "elevateUserToAdminRequestBody",
        elevateUserToAdminRequestBody,
      );
      const localVarPath = `/auth/elevateUserToAdmin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elevateUserToAdminRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser: async (
      followUserRequestBody: FollowUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'followUserRequestBody' is not null or undefined
      assertParamExists("followUser", "followUserRequestBody", followUserRequestBody);
      const localVarPath = `/userInteractions/followUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomById: async (
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getChatRoomByIdRequestBody' is not null or undefined
      assertParamExists(
        "getChatRoomById",
        "getChatRoomByIdRequestBody",
        getChatRoomByIdRequestBody,
      );
      const localVarPath = `/chat/getChatRoomById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getChatRoomByIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCountOfUnreadNotifications: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/notification/getCountOfUnreadNotifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditCardsStoredByUserId: async (
      body: object,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("getCreditCardsStoredByUserId", "body", body);
      const localVarPath = `/shopitem/getCreditCardsStoredByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages: async (
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfChatMessagesRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfChatMessages",
        "getPageOfChatMessagesRequestBody",
        getPageOfChatMessagesRequestBody,
      );
      const localVarPath = `/chat/getPageOfChatMessages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfChatMessagesRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatRooms: async (
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfChatRoomsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfChatRooms",
        "getPageOfChatRoomsRequestBody",
        getPageOfChatRoomsRequestBody,
      );
      const localVarPath = `/chat/getPageOfChatRooms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfChatRoomsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfCommentsByPostIdRequestBody} getPageOfCommentsByPostIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfCommentsByPostId: async (
      getPageOfCommentsByPostIdRequestBody: GetPageOfCommentsByPostIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfCommentsByPostIdRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfCommentsByPostId",
        "getPageOfCommentsByPostIdRequestBody",
        getPageOfCommentsByPostIdRequestBody,
      );
      const localVarPath = `/PostComment/getPageOfCommentsByPostId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfCommentsByPostIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfNotifications: async (
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfNotificationsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfNotifications",
        "getPageOfNotificationsRequestBody",
        getPageOfNotificationsRequestBody,
      );
      const localVarPath = `/notification/getPageOfNotifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfNotificationsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagRequestBody} getPageOfPostFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedHashtag: async (
      getPageOfPostFromFollowedHashtagRequestBody: GetPageOfPostFromFollowedHashtagRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfPostFromFollowedHashtagRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfPostFromFollowedHashtag",
        "getPageOfPostFromFollowedHashtagRequestBody",
        getPageOfPostFromFollowedHashtagRequestBody,
      );
      const localVarPath = `/feed/getPageOfPostFromFollowedHashtag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfPostFromFollowedHashtagRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersRequestBody} getPageOfPostFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedUsers: async (
      getPageOfPostFromFollowedUsersRequestBody: GetPageOfPostFromFollowedUsersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfPostFromFollowedUsersRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfPostFromFollowedUsers",
        "getPageOfPostFromFollowedUsersRequestBody",
        getPageOfPostFromFollowedUsersRequestBody,
      );
      const localVarPath = `/feed/getPageOfPostFromFollowedUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfPostFromFollowedUsersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfSavedPostsRequestBody} getPageOfSavedPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfSavedPosts: async (
      getPageOfSavedPostsRequestBody: GetPageOfSavedPostsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfSavedPostsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfSavedPosts",
        "getPageOfSavedPostsRequestBody",
        getPageOfSavedPostsRequestBody,
      );
      const localVarPath = `/post/getPageOfSavedPosts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfSavedPostsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowedByUserId: async (
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfUsersFollowedByUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfUsersFollowedByUserId",
        "getPageOfUsersFollowedByUserIdRequestBody",
        getPageOfUsersFollowedByUserIdRequestBody,
      );
      const localVarPath = `/user/getPageOfUsersFollowedByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfUsersFollowedByUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowingUserId: async (
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfUsersFollowingUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfUsersFollowingUserId",
        "getPageOfUsersFollowingUserIdRequestBody",
        getPageOfUsersFollowingUserIdRequestBody,
      );
      const localVarPath = `/user/getPageOfUsersFollowingUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfUsersFollowingUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordResetEmail: async (
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPasswordResetEmailRequestBody' is not null or undefined
      assertParamExists(
        "getPasswordResetEmail",
        "getPasswordResetEmailRequestBody",
        getPasswordResetEmailRequestBody,
      );
      const localVarPath = `/auth/getPasswordResetEmail`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPasswordResetEmailRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPostByIdRequestBody} getPostByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostById: async (
      getPostByIdRequestBody: GetPostByIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPostByIdRequestBody' is not null or undefined
      assertParamExists("getPostById", "getPostByIdRequestBody", getPostByIdRequestBody);
      const localVarPath = `/post/getPostById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPostByIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPostsByUserIdRequestBody} getPostsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsByUserId: async (
      getPostsByUserIdRequestBody: GetPostsByUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPostsByUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPostsByUserId",
        "getPostsByUserIdRequestBody",
        getPostsByUserIdRequestBody,
      );
      const localVarPath = `/post/getPostsByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPostsByUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPostsByUsernameRequestBody} getPostsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsByUsername: async (
      getPostsByUsernameRequestBody: GetPostsByUsernameRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPostsByUsernameRequestBody' is not null or undefined
      assertParamExists(
        "getPostsByUsername",
        "getPostsByUsernameRequestBody",
        getPostsByUsernameRequestBody,
      );
      const localVarPath = `/post/getPostsByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPostsByUsernameRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPostsScheduledByUserRequestBody} getPostsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser: async (
      getPostsScheduledByUserRequestBody: GetPostsScheduledByUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPostsScheduledByUserRequestBody' is not null or undefined
      assertParamExists(
        "getPostsScheduledByUser",
        "getPostsScheduledByUserRequestBody",
        getPostsScheduledByUserRequestBody,
      );
      const localVarPath = `/post/getPostsScheduledByUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPostsScheduledByUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetShopItemsByUserIdRequestBody} getShopItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopItemsByUserId: async (
      getShopItemsByUserIdRequestBody: GetShopItemsByUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getShopItemsByUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getShopItemsByUserId",
        "getShopItemsByUserIdRequestBody",
        getShopItemsByUserIdRequestBody,
      );
      const localVarPath = `/shopitem/getShopItemsByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getShopItemsByUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetShopItemsByUsernameRequestBody} getShopItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopItemsByUsername: async (
      getShopItemsByUsernameRequestBody: GetShopItemsByUsernameRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getShopItemsByUsernameRequestBody' is not null or undefined
      assertParamExists(
        "getShopItemsByUsername",
        "getShopItemsByUsernameRequestBody",
        getShopItemsByUsernameRequestBody,
      );
      const localVarPath = `/shopitem/getShopItemsByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getShopItemsByUsernameRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserContentFeedFilters: async (
      body: object,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("getUserContentFeedFilters", "body", body);
      const localVarPath = `/feed/getUserContentFeedFilters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile: async (
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUserProfileRequestBody' is not null or undefined
      assertParamExists(
        "getUserProfile",
        "getUserProfileRequestBody",
        getUserProfileRequestBody,
      );
      const localVarPath = `/user/GetUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUserProfileRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIds: async (
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUsersByIdsRequestBody' is not null or undefined
      assertParamExists(
        "getUsersByIds",
        "getUsersByIdsRequestBody",
        getUsersByIdsRequestBody,
      );
      const localVarPath = `/user/getUsersByIds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUsersByIdsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByUsernames: async (
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUsersByUsernamesRequestBody' is not null or undefined
      assertParamExists(
        "getUsersByUsernames",
        "getUsersByUsernamesRequestBody",
        getUsersByUsernamesRequestBody,
      );
      const localVarPath = `/user/getUsersByUsernames`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUsersByUsernamesRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: async (
      loginUserRequestBody: LoginUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginUserRequestBody' is not null or undefined
      assertParamExists("loginUser", "loginUserRequestBody", loginUserRequestBody);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShopItem: async (
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'purchaseShopItemRequestBody' is not null or undefined
      assertParamExists(
        "purchaseShopItem",
        "purchaseShopItemRequestBody",
        purchaseShopItemRequestBody,
      );
      const localVarPath = `/shopitem/purchaseShopItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        purchaseShopItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh-access-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      registerUserRequestBody: RegisterUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerUserRequestBody' is not null or undefined
      assertParamExists(
        "registerUser",
        "registerUserRequestBody",
        registerUserRequestBody,
      );
      const localVarPath = `/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCreditCard: async (
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeCreditCardRequestBody' is not null or undefined
      assertParamExists(
        "removeCreditCard",
        "removeCreditCardRequestBody",
        removeCreditCardRequestBody,
      );
      const localVarPath = `/shopitem/removeCreditCard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeCreditCardRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserLikeFromPublishedItem: async (
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeUserLikeFromPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "removeUserLikeFromPublishedItem",
        "removeUserLikeFromPublishedItemRequestBody",
        removeUserLikeFromPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/removeUserLikeFromPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeUserLikeFromPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resetPasswordRequestBody' is not null or undefined
      assertParamExists(
        "resetPassword",
        "resetPasswordRequestBody",
        resetPasswordRequestBody,
      );
      const localVarPath = `/auth/resetPassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resetPasswordRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForHashtags: async (
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForHashtagsRequestBody' is not null or undefined
      assertParamExists(
        "searchForHashtags",
        "searchForHashtagsRequestBody",
        searchForHashtagsRequestBody,
      );
      const localVarPath = `/discover/searchForHashtags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForHashtagsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForPosts: async (
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForPostsRequestBody' is not null or undefined
      assertParamExists(
        "searchForPosts",
        "searchForPostsRequestBody",
        searchForPostsRequestBody,
      );
      const localVarPath = `/discover/searchForPosts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForPostsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForUsers: async (
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForUsersRequestBody' is not null or undefined
      assertParamExists(
        "searchForUsers",
        "searchForUsersRequestBody",
        searchForUsersRequestBody,
      );
      const localVarPath = `/discover/searchForUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForUsersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername: async (
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchUserProfilesByUsernameRequestBody' is not null or undefined
      assertParamExists(
        "searchUserProfilesByUsername",
        "searchUserProfilesByUsernameRequestBody",
        searchUserProfilesByUsernameRequestBody,
      );
      const localVarPath = `/user/SearchUserProfilesByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchUserProfilesByUsernameRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataTypesToFrontend1: async (
      inlineObject5: InlineObject5,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject5' is not null or undefined
      assertParamExists("sendDataTypesToFrontend1", "inlineObject5", inlineObject5);
      const localVarPath = `/utilities/sendDataTypesToFrontend1`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserContentFeedFilters: async (
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUserContentFeedFiltersRequestBody' is not null or undefined
      assertParamExists(
        "setUserContentFeedFilters",
        "setUserContentFeedFiltersRequestBody",
        setUserContentFeedFiltersRequestBody,
      );
      const localVarPath = `/feed/setUserContentFeedFilters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserContentFeedFiltersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserHashtags: async (
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUserHashtagsRequestBody' is not null or undefined
      assertParamExists(
        "setUserHashtags",
        "setUserHashtagsRequestBody",
        setUserHashtagsRequestBody,
      );
      const localVarPath = `/user/SetUserHashtags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserHashtagsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sharePost: async (
      sharePostRequestBody: SharePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sharePostRequestBody' is not null or undefined
      assertParamExists("sharePost", "sharePostRequestBody", sharePostRequestBody);
      const localVarPath = `/post/sharePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser: async (
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unfollowUserRequestBody' is not null or undefined
      assertParamExists(
        "unfollowUser",
        "unfollowUserRequestBody",
        unfollowUserRequestBody,
      );
      const localVarPath = `/userInteractions/unfollowUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unfollowUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword: async (
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePasswordRequestBody' is not null or undefined
      assertParamExists(
        "updatePassword",
        "updatePasswordRequestBody",
        updatePasswordRequestBody,
      );
      const localVarPath = `/auth/updatePassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePasswordRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost: async (
      updatePostRequestBody: UpdatePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePostRequestBody' is not null or undefined
      assertParamExists("updatePost", "updatePostRequestBody", updatePostRequestBody);
      const localVarPath = `/post/updatePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem: async (
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'publishedItemId' is not null or undefined
      assertParamExists("updateShopItem", "publishedItemId", publishedItemId);
      const localVarPath = `/shopitem/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (publishedItemId !== undefined) {
        localVarFormParams.append("publishedItemId", publishedItemId as any);
      }

      if (description !== undefined) {
        localVarFormParams.append("description", description as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }
      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage: async (
      backgroundImage: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'backgroundImage' is not null or undefined
      assertParamExists("updateUserBackgroundImage", "backgroundImage", backgroundImage);
      const localVarPath = `/user/UpdateUserBackgroundImage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (backgroundImage !== undefined) {
        localVarFormParams.append("backgroundImage", backgroundImage as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile: async (
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserProfileRequestBody' is not null or undefined
      assertParamExists(
        "updateUserProfile",
        "updateUserProfileRequestBody",
        updateUserProfileRequestBody,
      );
      const localVarPath = `/user/UpdateUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserProfileRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture: async (
      profilePicture: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'profilePicture' is not null or undefined
      assertParamExists("updateUserProfilePicture", "profilePicture", profilePicture);
      const localVarPath = `/user/UpdateUserProfilePicture`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (profilePicture !== undefined) {
        localVarFormParams.append("profilePicture", profilePicture as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLikesPublishedItem: async (
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userLikesPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userLikesPublishedItem",
        "userLikesPublishedItemRequestBody",
        userLikesPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userLikesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLikesPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSavesPublishedItem: async (
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userSavesPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userSavesPublishedItem",
        "userSavesPublishedItemRequestBody",
        userSavesPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userSavesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userSavesPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUnsavesPublishedItem: async (
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeUserLikeFromPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userUnsavesPublishedItem",
        "removeUserLikeFromPublishedItemRequestBody",
        removeUserLikeFromPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userUnsavesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeUserLikeFromPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkResetPasswordTokenValidity(
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseCheckResetPasswordTokenValidityFailedCheckResetPasswordTokenValiditySuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkResetPasswordTokenValidity(
          checkResetPasswordTokenValidityRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CommentOnPostRequestBody} commentOnPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commentOnPost(
      commentOnPostRequestBody: CommentOnPostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseCommentOnPostFailedCommentOnPostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commentOnPost(
        commentOnPostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseCreateChatMessageFailedCreateChatMessageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChatMessage(
        createChatMessageRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChatMessageInNewChatRoom(
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseCreateChatMessageInNewChatRoomFailedCreateChatMessageInNewChatRoomSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createChatMessageInNewChatRoom(
          createChatMessageInNewRoomRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseCreatePostFailedCreatePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShopItem(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseCreateShopItemFailedCreateShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShopItem(
        mediaFiles,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChatMessage(
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDeleteChatMessageFailedDeleteChatMessageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatMessage(
        deleteChatMessageRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteCommentFromPostRequestBody} deleteCommentFromPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCommentFromPost(
      deleteCommentFromPostRequestBody: DeleteCommentFromPostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDeleteCommentFromPostFailedDeleteCommentFromPostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCommentFromPost(
        deleteCommentFromPostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDeletePostFailedDeletePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(
        deletePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDeleteShopItemFailedDeleteShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShopItem(
        deleteShopItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doesChatRoomExistWithUserIds(
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseDoesChatRoomExistWithUserIdsFailedDoesChatRoomExistWithUserIdsSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doesChatRoomExistWithUserIds(
          doesChatRoomExistWithUserIdsRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elevateUserToAdmin(
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseElevateUserToAdminFailedElevateUserToAdminSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elevateUserToAdmin(
        elevateUserToAdminRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async followUser(
      followUserRequestBody: FollowUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFollowUserFailedFollowUserSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(
        followUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatRoomById(
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetChatRoomByIdFailedGetChatRoomByIdSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomById(
        getChatRoomByIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCountOfUnreadNotifications(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetCountOfUnreadNotificationsFailedGetCountOfUnreadNotificationsSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCountOfUnreadNotifications(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCreditCardsStoredByUserId(
      body: object,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetCreditCardsStoredByUserIdFailedGetCreditCardsStoredByUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCreditCardsStoredByUserId(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfChatMessagesFailedGetPageOfChatMessagesSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfChatMessages(
        getPageOfChatMessagesRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfChatRooms(
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfChatRoomsFailedGetPageOfChatRoomsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfChatRooms(
        getPageOfChatRoomsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfCommentsByPostIdRequestBody} getPageOfCommentsByPostIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfCommentsByPostId(
      getPageOfCommentsByPostIdRequestBody: GetPageOfCommentsByPostIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfCommentsByPostIdFailureGetPageOfCommentsByPostIdSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfCommentsByPostId(
        getPageOfCommentsByPostIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfNotifications(
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfNotificationsFailedGetPageOfNotificationsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfNotifications(
        getPageOfNotificationsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagRequestBody} getPageOfPostFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfPostFromFollowedHashtag(
      getPageOfPostFromFollowedHashtagRequestBody: GetPageOfPostFromFollowedHashtagRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfPostFromFollowedHashtagFailedGetPageOfPostFromFollowedHashtagSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfPostFromFollowedHashtag(
          getPageOfPostFromFollowedHashtagRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersRequestBody} getPageOfPostFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfPostFromFollowedUsers(
      getPageOfPostFromFollowedUsersRequestBody: GetPageOfPostFromFollowedUsersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfPostFromFollowedUsersFailedGetPageOfPostFromFollowedUsersSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfPostFromFollowedUsers(
          getPageOfPostFromFollowedUsersRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfSavedPostsRequestBody} getPageOfSavedPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfSavedPosts(
      getPageOfSavedPostsRequestBody: GetPageOfSavedPostsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfSavedPostsFailedGetPageOfSavedPostsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfSavedPosts(
        getPageOfSavedPostsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfUsersFollowedByUserId(
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfUsersFollowedByUserIdFailedGetPageOfUsersFollowedByUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfUsersFollowedByUserId(
          getPageOfUsersFollowedByUserIdRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfUsersFollowingUserId(
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPageOfUsersFollowingUserIdFailedGetPageOfUsersFollowingUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfUsersFollowingUserId(
          getPageOfUsersFollowingUserIdRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPasswordResetEmail(
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseGetPasswordResetEmailFailedGetPasswordResetEmailSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordResetEmail(
        getPasswordResetEmailRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPostByIdRequestBody} getPostByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostById(
      getPostByIdRequestBody: GetPostByIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPostByIdFailedGetPostByIdSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostById(
        getPostByIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPostsByUserIdRequestBody} getPostsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostsByUserId(
      getPostsByUserIdRequestBody: GetPostsByUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPostsByUsernameFailedGetPostsByUsernameSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByUserId(
        getPostsByUserIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPostsByUsernameRequestBody} getPostsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostsByUsername(
      getPostsByUsernameRequestBody: GetPostsByUsernameRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPostsByUsernameFailedGetPostsByUsernameSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsByUsername(
        getPostsByUsernameRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPostsScheduledByUserRequestBody} getPostsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostsScheduledByUser(
      getPostsScheduledByUserRequestBody: GetPostsScheduledByUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetPostsScheduledByUserFailedGetPostsScheduledByUserSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsScheduledByUser(
        getPostsScheduledByUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetShopItemsByUserIdRequestBody} getShopItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShopItemsByUserId(
      getShopItemsByUserIdRequestBody: GetShopItemsByUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetShopItemsByUsernameFailedGetShopItemsByUsernameSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShopItemsByUserId(
        getShopItemsByUserIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetShopItemsByUsernameRequestBody} getShopItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getShopItemsByUsername(
      getShopItemsByUsernameRequestBody: GetShopItemsByUsernameRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetShopItemsByUsernameFailedGetShopItemsByUsernameSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getShopItemsByUsername(
        getShopItemsByUsernameRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserContentFeedFilters(
      body: object,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetUserContentFeedFiltersFailedGetUserContentFeedFiltersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserContentFeedFilters(
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserProfile(
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetUserProfileFailedGetUserProfileSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(
        getUserProfileRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersByIds(
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetUsersByIdsFailedGetUsersByIdsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByIds(
        getUsersByIdsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersByUsernames(
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseGetUsersByUsernamesFailedGetUsersByUsernamesSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByUsernames(
        getUsersByUsernamesRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUser(
      loginUserRequestBody: LoginUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseAuthFailedAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(
        loginUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchaseShopItem(
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponsePurchaseShopItemFailedPurchaseShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseShopItem(
        purchaseShopItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshAccessToken(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseAuthFailedAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      registerUserRequestBody: RegisterUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseRegisterUserFailedAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        registerUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCreditCard(
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseRemoveCreditCardFailedRemoveCreditCardSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeCreditCard(
        removeCreditCardRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserLikeFromPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeUserLikeFromPublishedItem(
          removeUserLikeFromPublishedItemRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<HTTPResponseResetPasswordFailedResetPasswordSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(
        resetPasswordRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForHashtags(
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSearchForHashtagsFailedSearchForHashtagsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForHashtags(
        searchForHashtagsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForPosts(
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSearchForPostsFailedSearchForPostsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForPosts(
        searchForPostsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForUsers(
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSearchForUsersFailedSearchForUsersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForUsers(
        searchForUsersRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchUserProfilesByUsername(
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSearchUserProfilesByUsernameFailedSearchUserProfilesByUsernameSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchUserProfilesByUsername(
          searchUserProfilesByUsernameRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendDataTypesToFrontend1(
      inlineObject5: InlineObject5,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendDataTypesToFrontend1(
        inlineObject5,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserContentFeedFilters(
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserContentFeedFilters(
        setUserContentFeedFiltersRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserHashtags(
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSetUserHashtagsFailedSetUserHashtagsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserHashtags(
        setUserHashtagsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sharePost(
      sharePostRequestBody: SharePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseSharePostFailedSharePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sharePost(
        sharePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfollowUser(
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(
        unfollowUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePassword(
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdatePasswordFailedUpdatePasswordSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(
        updatePasswordRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePost(
      updatePostRequestBody: UpdatePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdatePostFailedUpdatePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(
        updatePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShopItem(
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdateShopItemFailedUpdateShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateShopItem(
        publishedItemId,
        description,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdateUserBackgroundImageFailedUpdateUserBackgroundImageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBackgroundImage(
        backgroundImage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfile(
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdateUserProfileFailedUpdateUserProfileSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(
        updateUserProfileRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUpdateUserProfilePictureFailedUpdateUserProfilePictureSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfilePicture(
        profilePicture,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userLikesPublishedItem(
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUserLikesPublishedItemFailedUserLikesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userLikesPublishedItem(
        userLikesPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userSavesPublishedItem(
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUserSavesPublishedItemFailedUserSavesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userSavesPublishedItem(
        userSavesPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userUnsavesPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SecuredHTTPResponseUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userUnsavesPublishedItem(
        removeUserLikeFromPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenValidity(
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options?: any,
    ): AxiosPromise<HTTPResponseCheckResetPasswordTokenValidityFailedCheckResetPasswordTokenValiditySuccess> {
      return localVarFp
        .checkResetPasswordTokenValidity(
          checkResetPasswordTokenValidityRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CommentOnPostRequestBody} commentOnPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commentOnPost(
      commentOnPostRequestBody: CommentOnPostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseCommentOnPostFailedCommentOnPostSuccess> {
      return localVarFp
        .commentOnPost(commentOnPostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseCreateChatMessageFailedCreateChatMessageSuccess> {
      return localVarFp
        .createChatMessage(createChatMessageRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessageInNewChatRoom(
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseCreateChatMessageInNewChatRoomFailedCreateChatMessageInNewChatRoomSuccess> {
      return localVarFp
        .createChatMessageInNewChatRoom(createChatMessageInNewRoomRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseCreatePostFailedCreatePostSuccess> {
      return localVarFp
        .createPost(
          mediaFiles,
          caption,
          hashtags,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseCreateShopItemFailedCreateShopItemSuccess> {
      return localVarFp
        .createShopItem(
          mediaFiles,
          caption,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          collaboratorUserIds,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessage(
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDeleteChatMessageFailedDeleteChatMessageSuccess> {
      return localVarFp
        .deleteChatMessage(deleteChatMessageRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteCommentFromPostRequestBody} deleteCommentFromPostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCommentFromPost(
      deleteCommentFromPostRequestBody: DeleteCommentFromPostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDeleteCommentFromPostFailedDeleteCommentFromPostSuccess> {
      return localVarFp
        .deleteCommentFromPost(deleteCommentFromPostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDeletePostFailedDeletePostSuccess> {
      return localVarFp
        .deletePost(deletePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDeleteShopItemFailedDeleteShopItemSuccess> {
      return localVarFp
        .deleteShopItem(deleteShopItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesChatRoomExistWithUserIds(
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseDoesChatRoomExistWithUserIdsFailedDoesChatRoomExistWithUserIdsSuccess> {
      return localVarFp
        .doesChatRoomExistWithUserIds(doesChatRoomExistWithUserIdsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elevateUserToAdmin(
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseElevateUserToAdminFailedElevateUserToAdminSuccess> {
      return localVarFp
        .elevateUserToAdmin(elevateUserToAdminRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser(
      followUserRequestBody: FollowUserRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFollowUserFailedFollowUserSuccess> {
      return localVarFp
        .followUser(followUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomById(
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetChatRoomByIdFailedGetChatRoomByIdSuccess> {
      return localVarFp
        .getChatRoomById(getChatRoomByIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCountOfUnreadNotifications(
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetCountOfUnreadNotificationsFailedGetCountOfUnreadNotificationsSuccess> {
      return localVarFp
        .getCountOfUnreadNotifications(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditCardsStoredByUserId(
      body: object,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetCreditCardsStoredByUserIdFailedGetCreditCardsStoredByUserIdSuccess> {
      return localVarFp
        .getCreditCardsStoredByUserId(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfChatMessagesFailedGetPageOfChatMessagesSuccess> {
      return localVarFp
        .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatRooms(
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfChatRoomsFailedGetPageOfChatRoomsSuccess> {
      return localVarFp
        .getPageOfChatRooms(getPageOfChatRoomsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfCommentsByPostIdRequestBody} getPageOfCommentsByPostIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfCommentsByPostId(
      getPageOfCommentsByPostIdRequestBody: GetPageOfCommentsByPostIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfCommentsByPostIdFailureGetPageOfCommentsByPostIdSuccess> {
      return localVarFp
        .getPageOfCommentsByPostId(getPageOfCommentsByPostIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfNotifications(
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfNotificationsFailedGetPageOfNotificationsSuccess> {
      return localVarFp
        .getPageOfNotifications(getPageOfNotificationsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedHashtagRequestBody} getPageOfPostFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedHashtag(
      getPageOfPostFromFollowedHashtagRequestBody: GetPageOfPostFromFollowedHashtagRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfPostFromFollowedHashtagFailedGetPageOfPostFromFollowedHashtagSuccess> {
      return localVarFp
        .getPageOfPostFromFollowedHashtag(
          getPageOfPostFromFollowedHashtagRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfPostFromFollowedUsersRequestBody} getPageOfPostFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfPostFromFollowedUsers(
      getPageOfPostFromFollowedUsersRequestBody: GetPageOfPostFromFollowedUsersRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfPostFromFollowedUsersFailedGetPageOfPostFromFollowedUsersSuccess> {
      return localVarFp
        .getPageOfPostFromFollowedUsers(
          getPageOfPostFromFollowedUsersRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfSavedPostsRequestBody} getPageOfSavedPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfSavedPosts(
      getPageOfSavedPostsRequestBody: GetPageOfSavedPostsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfSavedPostsFailedGetPageOfSavedPostsSuccess> {
      return localVarFp
        .getPageOfSavedPosts(getPageOfSavedPostsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowedByUserId(
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfUsersFollowedByUserIdFailedGetPageOfUsersFollowedByUserIdSuccess> {
      return localVarFp
        .getPageOfUsersFollowedByUserId(
          getPageOfUsersFollowedByUserIdRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowingUserId(
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPageOfUsersFollowingUserIdFailedGetPageOfUsersFollowingUserIdSuccess> {
      return localVarFp
        .getPageOfUsersFollowingUserId(getPageOfUsersFollowingUserIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordResetEmail(
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options?: any,
    ): AxiosPromise<HTTPResponseGetPasswordResetEmailFailedGetPasswordResetEmailSuccess> {
      return localVarFp
        .getPasswordResetEmail(getPasswordResetEmailRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPostByIdRequestBody} getPostByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostById(
      getPostByIdRequestBody: GetPostByIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPostByIdFailedGetPostByIdSuccess> {
      return localVarFp
        .getPostById(getPostByIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPostsByUserIdRequestBody} getPostsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsByUserId(
      getPostsByUserIdRequestBody: GetPostsByUserIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPostsByUsernameFailedGetPostsByUsernameSuccess> {
      return localVarFp
        .getPostsByUserId(getPostsByUserIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPostsByUsernameRequestBody} getPostsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsByUsername(
      getPostsByUsernameRequestBody: GetPostsByUsernameRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPostsByUsernameFailedGetPostsByUsernameSuccess> {
      return localVarFp
        .getPostsByUsername(getPostsByUsernameRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPostsScheduledByUserRequestBody} getPostsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser(
      getPostsScheduledByUserRequestBody: GetPostsScheduledByUserRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetPostsScheduledByUserFailedGetPostsScheduledByUserSuccess> {
      return localVarFp
        .getPostsScheduledByUser(getPostsScheduledByUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetShopItemsByUserIdRequestBody} getShopItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopItemsByUserId(
      getShopItemsByUserIdRequestBody: GetShopItemsByUserIdRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetShopItemsByUsernameFailedGetShopItemsByUsernameSuccess> {
      return localVarFp
        .getShopItemsByUserId(getShopItemsByUserIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetShopItemsByUsernameRequestBody} getShopItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getShopItemsByUsername(
      getShopItemsByUsernameRequestBody: GetShopItemsByUsernameRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetShopItemsByUsernameFailedGetShopItemsByUsernameSuccess> {
      return localVarFp
        .getShopItemsByUsername(getShopItemsByUsernameRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserContentFeedFilters(
      body: object,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetUserContentFeedFiltersFailedGetUserContentFeedFiltersSuccess> {
      return localVarFp
        .getUserContentFeedFilters(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetUserProfileFailedGetUserProfileSuccess> {
      return localVarFp
        .getUserProfile(getUserProfileRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIds(
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetUsersByIdsFailedGetUsersByIdsSuccess> {
      return localVarFp
        .getUsersByIds(getUsersByIdsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByUsernames(
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseGetUsersByUsernamesFailedGetUsersByUsernamesSuccess> {
      return localVarFp
        .getUsersByUsernames(getUsersByUsernamesRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      loginUserRequestBody: LoginUserRequestBody,
      options?: any,
    ): AxiosPromise<HTTPResponseAuthFailedAuthSuccess> {
      return localVarFp
        .loginUser(loginUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShopItem(
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponsePurchaseShopItemFailedPurchaseShopItemSuccess> {
      return localVarFp
        .purchaseShopItem(purchaseShopItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken(options?: any): AxiosPromise<HTTPResponseAuthFailedAuthSuccess> {
      return localVarFp
        .refreshAccessToken(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      registerUserRequestBody: RegisterUserRequestBody,
      options?: any,
    ): AxiosPromise<HTTPResponseRegisterUserFailedAuthSuccess> {
      return localVarFp
        .registerUser(registerUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCreditCard(
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseRemoveCreditCardFailedRemoveCreditCardSuccess> {
      return localVarFp
        .removeCreditCard(removeCreditCardRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserLikeFromPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse> {
      return localVarFp
        .removeUserLikeFromPublishedItem(
          removeUserLikeFromPublishedItemRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options?: any,
    ): AxiosPromise<HTTPResponseResetPasswordFailedResetPasswordSuccess> {
      return localVarFp
        .resetPassword(resetPasswordRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForHashtags(
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSearchForHashtagsFailedSearchForHashtagsSuccess> {
      return localVarFp
        .searchForHashtags(searchForHashtagsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForPosts(
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSearchForPostsFailedSearchForPostsSuccess> {
      return localVarFp
        .searchForPosts(searchForPostsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForUsers(
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSearchForUsersFailedSearchForUsersSuccess> {
      return localVarFp
        .searchForUsers(searchForUsersRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername(
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSearchUserProfilesByUsernameFailedSearchUserProfilesByUsernameSuccess> {
      return localVarFp
        .searchUserProfilesByUsername(searchUserProfilesByUsernameRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataTypesToFrontend1(
      inlineObject5: InlineObject5,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .sendDataTypesToFrontend1(inlineObject5, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserContentFeedFilters(
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess> {
      return localVarFp
        .setUserContentFeedFilters(setUserContentFeedFiltersRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserHashtags(
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSetUserHashtagsFailedSetUserHashtagsSuccess> {
      return localVarFp
        .setUserHashtags(setUserHashtagsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sharePost(
      sharePostRequestBody: SharePostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseSharePostFailedSharePostSuccess> {
      return localVarFp
        .sharePost(sharePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser(
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse> {
      return localVarFp
        .unfollowUser(unfollowUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword(
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdatePasswordFailedUpdatePasswordSuccess> {
      return localVarFp
        .updatePassword(updatePasswordRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost(
      updatePostRequestBody: UpdatePostRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdatePostFailedUpdatePostSuccess> {
      return localVarFp
        .updatePost(updatePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem(
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdateShopItemFailedUpdateShopItemSuccess> {
      return localVarFp
        .updateShopItem(
          publishedItemId,
          description,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          collaboratorUserIds,
          mediaFiles,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdateUserBackgroundImageFailedUpdateUserBackgroundImageSuccess> {
      return localVarFp
        .updateUserBackgroundImage(backgroundImage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile(
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdateUserProfileFailedUpdateUserProfileSuccess> {
      return localVarFp
        .updateUserProfile(updateUserProfileRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUpdateUserProfilePictureFailedUpdateUserProfilePictureSuccess> {
      return localVarFp
        .updateUserProfilePicture(profilePicture, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLikesPublishedItem(
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUserLikesPublishedItemFailedUserLikesPublishedItemSuccess> {
      return localVarFp
        .userLikesPublishedItem(userLikesPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSavesPublishedItem(
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUserSavesPublishedItemFailedUserSavesPublishedItemSuccess> {
      return localVarFp
        .userSavesPublishedItem(userSavesPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUnsavesPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<SecuredHTTPResponseUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess> {
      return localVarFp
        .userUnsavesPublishedItem(removeUserLikeFromPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public checkResetPasswordTokenValidity(
    checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .checkResetPasswordTokenValidity(
        checkResetPasswordTokenValidityRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CommentOnPostRequestBody} commentOnPostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public commentOnPost(
    commentOnPostRequestBody: CommentOnPostRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .commentOnPost(commentOnPostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChatMessage(
    createChatMessageRequestBody: CreateChatMessageRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createChatMessage(createChatMessageRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChatMessageInNewChatRoom(
    createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createChatMessageInNewChatRoom(createChatMessageInNewRoomRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<any>} mediaFiles
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPost(
    mediaFiles: Array<any>,
    caption: string,
    hashtags: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<any>} mediaFiles
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} title
   * @param {string} price
   * @param {string} scheduledPublicationTimestamp
   * @param {string} collaboratorUserIds
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createShopItem(
    mediaFiles: Array<any>,
    caption: string,
    hashtags: string,
    title: string,
    price: string,
    scheduledPublicationTimestamp: string,
    collaboratorUserIds: string,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createShopItem(
        mediaFiles,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChatMessage(
    deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteChatMessage(deleteChatMessageRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteCommentFromPostRequestBody} deleteCommentFromPostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteCommentFromPost(
    deleteCommentFromPostRequestBody: DeleteCommentFromPostRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteCommentFromPost(deleteCommentFromPostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeletePostRequestBody} deletePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deletePost(deletePostRequestBody: DeletePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .deletePost(deletePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteShopItem(
    deleteShopItemRequestBody: DeleteShopItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteShopItem(deleteShopItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public doesChatRoomExistWithUserIds(
    doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .doesChatRoomExistWithUserIds(doesChatRoomExistWithUserIdsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public elevateUserToAdmin(
    elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .elevateUserToAdmin(elevateUserToAdminRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FollowUserRequestBody} followUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public followUser(followUserRequestBody: FollowUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .followUser(followUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChatRoomById(
    getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getChatRoomById(getChatRoomByIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCountOfUnreadNotifications(options?: any) {
    return DefaultApiFp(this.configuration)
      .getCountOfUnreadNotifications(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCreditCardsStoredByUserId(body: object, options?: any) {
    return DefaultApiFp(this.configuration)
      .getCreditCardsStoredByUserId(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfChatMessages(
    getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfChatRooms(
    getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfChatRooms(getPageOfChatRoomsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfCommentsByPostIdRequestBody} getPageOfCommentsByPostIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfCommentsByPostId(
    getPageOfCommentsByPostIdRequestBody: GetPageOfCommentsByPostIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfCommentsByPostId(getPageOfCommentsByPostIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfNotifications(
    getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfNotifications(getPageOfNotificationsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfPostFromFollowedHashtagRequestBody} getPageOfPostFromFollowedHashtagRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfPostFromFollowedHashtag(
    getPageOfPostFromFollowedHashtagRequestBody: GetPageOfPostFromFollowedHashtagRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfPostFromFollowedHashtag(
        getPageOfPostFromFollowedHashtagRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfPostFromFollowedUsersRequestBody} getPageOfPostFromFollowedUsersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfPostFromFollowedUsers(
    getPageOfPostFromFollowedUsersRequestBody: GetPageOfPostFromFollowedUsersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfPostFromFollowedUsers(getPageOfPostFromFollowedUsersRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfSavedPostsRequestBody} getPageOfSavedPostsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfSavedPosts(
    getPageOfSavedPostsRequestBody: GetPageOfSavedPostsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfSavedPosts(getPageOfSavedPostsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfUsersFollowedByUserId(
    getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfUsersFollowedByUserId(getPageOfUsersFollowedByUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfUsersFollowingUserId(
    getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfUsersFollowingUserId(getPageOfUsersFollowingUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPasswordResetEmail(
    getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPasswordResetEmail(getPasswordResetEmailRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPostByIdRequestBody} getPostByIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostById(getPostByIdRequestBody: GetPostByIdRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .getPostById(getPostByIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPostsByUserIdRequestBody} getPostsByUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostsByUserId(
    getPostsByUserIdRequestBody: GetPostsByUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostsByUserId(getPostsByUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPostsByUsernameRequestBody} getPostsByUsernameRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostsByUsername(
    getPostsByUsernameRequestBody: GetPostsByUsernameRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostsByUsername(getPostsByUsernameRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPostsScheduledByUserRequestBody} getPostsScheduledByUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostsScheduledByUser(
    getPostsScheduledByUserRequestBody: GetPostsScheduledByUserRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostsScheduledByUser(getPostsScheduledByUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetShopItemsByUserIdRequestBody} getShopItemsByUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getShopItemsByUserId(
    getShopItemsByUserIdRequestBody: GetShopItemsByUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getShopItemsByUserId(getShopItemsByUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetShopItemsByUsernameRequestBody} getShopItemsByUsernameRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getShopItemsByUsername(
    getShopItemsByUsernameRequestBody: GetShopItemsByUsernameRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getShopItemsByUsername(getShopItemsByUsernameRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserContentFeedFilters(body: object, options?: any) {
    return DefaultApiFp(this.configuration)
      .getUserContentFeedFilters(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUserProfileRequestBody} getUserProfileRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserProfile(
    getUserProfileRequestBody: GetUserProfileRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUserProfile(getUserProfileRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsersByIds(
    getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUsersByIds(getUsersByIdsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsersByUsernames(
    getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUsersByUsernames(getUsersByUsernamesRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginUserRequestBody} loginUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public loginUser(loginUserRequestBody: LoginUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .loginUser(loginUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logout(options?: any) {
    return DefaultApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public purchaseShopItem(
    purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .purchaseShopItem(purchaseShopItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refreshAccessToken(options?: any) {
    return DefaultApiFp(this.configuration)
      .refreshAccessToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RegisterUserRequestBody} registerUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerUser(registerUserRequestBody: RegisterUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .registerUser(registerUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public removeCreditCard(
    removeCreditCardRequestBody: RemoveCreditCardRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .removeCreditCard(removeCreditCardRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public removeUserLikeFromPublishedItem(
    removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .removeUserLikeFromPublishedItem(
        removeUserLikeFromPublishedItemRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ResetPasswordRequestBody} resetPasswordRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public resetPassword(
    resetPasswordRequestBody: ResetPasswordRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .resetPassword(resetPasswordRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForHashtags(
    searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForHashtags(searchForHashtagsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForPostsRequestBody} searchForPostsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForPosts(
    searchForPostsRequestBody: SearchForPostsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForPosts(searchForPostsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForUsersRequestBody} searchForUsersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForUsers(
    searchForUsersRequestBody: SearchForUsersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForUsers(searchForUsersRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchUserProfilesByUsername(
    searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchUserProfilesByUsername(searchUserProfilesByUsernameRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject5} inlineObject5
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sendDataTypesToFrontend1(inlineObject5: InlineObject5, options?: any) {
    return DefaultApiFp(this.configuration)
      .sendDataTypesToFrontend1(inlineObject5, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setUserContentFeedFilters(
    setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .setUserContentFeedFilters(setUserContentFeedFiltersRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setUserHashtags(
    setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .setUserHashtags(setUserHashtagsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SharePostRequestBody} sharePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sharePost(sharePostRequestBody: SharePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .sharePost(sharePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UnfollowUserRequestBody} unfollowUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unfollowUser(unfollowUserRequestBody: UnfollowUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .unfollowUser(unfollowUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePassword(
    updatePasswordRequestBody: UpdatePasswordRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updatePassword(updatePasswordRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePostRequestBody} updatePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePost(updatePostRequestBody: UpdatePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .updatePost(updatePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} publishedItemId
   * @param {string} [description]
   * @param {string} [hashtags]
   * @param {string} [title]
   * @param {string} [price]
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {string} [collaboratorUserIds]
   * @param {Array<any>} [mediaFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateShopItem(
    publishedItemId: string,
    description?: string,
    hashtags?: string,
    title?: string,
    price?: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    collaboratorUserIds?: string,
    mediaFiles?: Array<any>,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateShopItem(
        publishedItemId,
        description,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} backgroundImage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserBackgroundImage(backgroundImage: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserBackgroundImage(backgroundImage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfile(
    updateUserProfileRequestBody: UpdateUserProfileRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateUserProfile(updateUserProfileRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} profilePicture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfilePicture(profilePicture: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserProfilePicture(profilePicture, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userLikesPublishedItem(
    userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userLikesPublishedItem(userLikesPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userSavesPublishedItem(
    userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userSavesPublishedItem(userSavesPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userUnsavesPublishedItem(
    removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userUnsavesPublishedItem(removeUserLikeFromPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
