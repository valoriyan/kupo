/* tslint:disable */
/* eslint-disable */
/**
 * kupono-backend
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
import { Configuration } from "../configuration";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "../common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "../base";
// @ts-ignore
import { CheckResetPasswordTokenValidityRequestBody } from "../types";
// @ts-ignore
import { CreateChatMessageInNewRoomRequestBody } from "../types";
// @ts-ignore
import { CreateChatMessageRequestBody } from "../types";
// @ts-ignore
import { CreatePublishedItemCommentRequestBody } from "../types";
// @ts-ignore
import { DeleteChatMessageRequestBody } from "../types";
// @ts-ignore
import { DeletePostRequestBody } from "../types";
// @ts-ignore
import { DeletePublishedItemCommentRequestBody } from "../types";
// @ts-ignore
import { DeleteShopItemRequestBody } from "../types";
// @ts-ignore
import { DoesChatRoomExistWithUserIdsRequestBody } from "../types";
// @ts-ignore
import { EitherAuthFailedReasonAuthSuccess } from "../types";
// @ts-ignore
import { EitherCheckResetPasswordTokenValidityFailedReasonCheckResetPasswordTokenValiditySuccess } from "../types";
// @ts-ignore
import { EitherDeletePostFailedDeletePostSuccess } from "../types";
// @ts-ignore
import { EitherDeleteShopItemFailedDeleteShopItemSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrAuthFailedReasonAuthSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrCreateChatMessageFailedReasonCreateChatMessageSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrCreateChatMessageInNewChatRoomFailedReasonCreateChatMessageInNewChatRoomSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrCreatePostFailedReasonCreatePostSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrCreatePublishedItemCommentFailedReasonCreatePublishedItemCommentSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrCreateShopItemFailedReasonCreateShopItemSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrDeleteChatMessageFailedReasonDeleteChatMessageSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrDeletePublishedItemCommentFailedReasonDeletePublishedItemCommentSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrDoesChatRoomExistWithUserIdsFailedReasonDoesChatRoomExistWithUserIdsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrElevateUserToAdminFailedElevateUserToAdminSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetChatRoomByIdFailedReasonGetChatRoomByIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetCountOfUnreadNotificationsFailedReasonGetCountOfUnreadNotificationsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetCreditCardsStoredByUserIdFailedReasonGetCreditCardsStoredByUserIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfAllPublishedItemsFailedReasonGetPageOfAllPublishedItemsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfChatMessagesFailedReasonGetPageOfChatMessagesSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfChatRoomsFailedReasonGetPageOfChatRoomsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfNotificationsFailedReasonGetPageOfNotificationsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfUsersFollowedByUserIdFailedReasonGetPageOfUsersFollowedByUserIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPageOfUsersFollowingUserIdFailedReasonGetPageOfUsersFollowingUserIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPasswordResetEmailFailedGetPasswordResetEmailSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPublishedItemByIdFailedReasonGetPublishedItemByIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPublishedItemsByUsernameFailedReasonGetPublishedItemsByUsernameSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedHashtagFailedReasonGetPublishedItemsFromFollowedHashtagSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedUsersFailedReasonGetPublishedItemsFromFollowedUsersSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetSavedPublishedItemsFailedReasonGetSavedPublishedItemsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetUserContentFeedFiltersFailedReasonGetUserContentFeedFiltersSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetUserProfileFailedReasonGetUserProfileSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetUsersByIdsFailedReasonGetUsersByIdsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrGetUsersByUsernamesFailedReasonGetUsersByUsernamesSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrMakeCreditCardPrimaryFailedReasonMakeCreditCardPrimarySuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrMarkChatRoomAsReadFailedReasonMarkChatRoomAsReadSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrPurchaseShopItemFailedReasonPurchaseShopItemSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrReadPageOfCommentsByPublishedItemIdFailedReasonReadPageOfCommentsByPublishedItemIdSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrRegisterUserFailedReasonAuthSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrRemoveCreditCardFailedReasonRemoveCreditCardSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrResetPasswordFailedReasonResetPasswordSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSearchForHashtagsFailedReasonSearchForHashtagsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSearchForPostsFailedReasonSearchForPostsSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSearchForUsersFailedReasonSearchForUsersSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSearchUserProfilesByUsernameFailedReasonSearchUserProfilesByUsernameSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrSharePostFailedReasonSharePostSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrStoreCreditCardFailedReasonStoreCreditCardSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdatePasswordFailedUpdatePasswordSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdatePostFailedReasonUpdatePostSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdateShopItemFailedReasonUpdateShopItemSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdateUserBackgroundImageFailedReasonUpdateUserBackgroundImageSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdateUserProfileFailedReasonUpdateUserProfileSuccess } from "../types";
// @ts-ignore
import { EitherErrorReasonTypesStringOrUpdateUserProfilePictureFailedReasonUpdateUserProfilePictureSuccess } from "../types";
// @ts-ignore
import { EitherFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse } from "../types";
// @ts-ignore
import { EitherFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse } from "../types";
// @ts-ignore
import { EitherFollowUserFailedFollowUserSuccess } from "../types";
// @ts-ignore
import { EitherGetFollowerRequestsFailedGetFollowerRequestsSuccess } from "../types";
// @ts-ignore
import { EitherGetPublishedItemsScheduledByUserFailedGetPublishedItemsScheduledByUserSuccess } from "../types";
// @ts-ignore
import { EitherResolveFollowRequestFailedResolveFollowRequestSuccess } from "../types";
// @ts-ignore
import { EitherSetUserHashtagsFailedSetUserHashtagsSuccess } from "../types";
// @ts-ignore
import { EitherUserLikesPublishedItemFailedUserLikesPublishedItemSuccess } from "../types";
// @ts-ignore
import { EitherUserSavesPublishedItemFailedUserSavesPublishedItemSuccess } from "../types";
// @ts-ignore
import { EitherUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess } from "../types";
// @ts-ignore
import { ElevateUserToAdminRequestBody } from "../types";
// @ts-ignore
import { FollowUserRequestBody } from "../types";
// @ts-ignore
import { GetChatRoomByIdRequestBody } from "../types";
// @ts-ignore
import { GetPageOfAllPublishedItemsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfChatMessagesRequestBody } from "../types";
// @ts-ignore
import { GetPageOfChatRoomsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfNotificationsRequestBody } from "../types";
// @ts-ignore
import { GetPageOfUsersFollowedByUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPageOfUsersFollowingUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPasswordResetEmailRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemByIdRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemsByUserIdRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemsByUsernameRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemsFromFollowedHashtagRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemsFromFollowedUsersRequestBody } from "../types";
// @ts-ignore
import { GetPublishedItemsScheduledByUserRequestBody } from "../types";
// @ts-ignore
import { GetSavedPublishedItemsRequestBody } from "../types";
// @ts-ignore
import { GetUserProfileRequestBody } from "../types";
// @ts-ignore
import { GetUsersByIdsRequestBody } from "../types";
// @ts-ignore
import { GetUsersByUsernamesRequestBody } from "../types";
// @ts-ignore
import { InlineObject5 } from "../types";
// @ts-ignore
import { InlineResponse200 } from "../types";
// @ts-ignore
import { LoginUserRequestBody } from "../types";
// @ts-ignore
import { MakeCreditCardPrimaryRequestBody } from "../types";
// @ts-ignore
import { MarkChatRoomAsReadRequestBody } from "../types";
// @ts-ignore
import { PurchaseShopItemRequestBody } from "../types";
// @ts-ignore
import { ReadPageOfCommentsByPublishedItemIdRequestBody } from "../types";
// @ts-ignore
import { RegisterUserRequestBody } from "../types";
// @ts-ignore
import { RemoveCreditCardRequestBody } from "../types";
// @ts-ignore
import { RemoveUserLikeFromPublishedItemRequestBody } from "../types";
// @ts-ignore
import { ResetPasswordRequestBody } from "../types";
// @ts-ignore
import { ResolveFollowRequestRequestBody } from "../types";
// @ts-ignore
import { SearchForHashtagsRequestBody } from "../types";
// @ts-ignore
import { SearchForPostsRequestBody } from "../types";
// @ts-ignore
import { SearchForUsersRequestBody } from "../types";
// @ts-ignore
import { SearchUserProfilesByUsernameRequestBody } from "../types";
// @ts-ignore
import { SetUserContentFeedFiltersRequestBody } from "../types";
// @ts-ignore
import { SetUserHashtagsRequestBody } from "../types";
// @ts-ignore
import { SharePostRequestBody } from "../types";
// @ts-ignore
import { StoreCreditCardRequestBody } from "../types";
// @ts-ignore
import { UnfollowUserRequestBody } from "../types";
// @ts-ignore
import { UpdatePasswordRequestBody } from "../types";
// @ts-ignore
import { UpdatePostRequestBody } from "../types";
// @ts-ignore
import { UpdateUserProfileRequestBody } from "../types";
// @ts-ignore
import { UserLikesPublishedItemRequestBody } from "../types";
// @ts-ignore
import { UserSavesPublishedItemRequestBody } from "../types";
/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenValidity: async (
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'checkResetPasswordTokenValidityRequestBody' is not null or undefined
      assertParamExists(
        "checkResetPasswordTokenValidity",
        "checkResetPasswordTokenValidityRequestBody",
        checkResetPasswordTokenValidityRequestBody,
      );
      const localVarPath = `/auth/checkResetPasswordTokenValidity`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        checkResetPasswordTokenValidityRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage: async (
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatMessageRequestBody' is not null or undefined
      assertParamExists(
        "createChatMessage",
        "createChatMessageRequestBody",
        createChatMessageRequestBody,
      );
      const localVarPath = `/chat/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatMessageRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessageInNewChatRoom: async (
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatMessageInNewRoomRequestBody' is not null or undefined
      assertParamExists(
        "createChatMessageInNewChatRoom",
        "createChatMessageInNewRoomRequestBody",
        createChatMessageInNewRoomRequestBody,
      );
      const localVarPath = `/chat/createChatMessageInNewChatRoom`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatMessageInNewRoomRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost: async (
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'mediaFiles' is not null or undefined
      assertParamExists("createPost", "mediaFiles", mediaFiles);
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createPost", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createPost", "hashtags", hashtags);
      const localVarPath = `/post/createPost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {CreatePublishedItemCommentRequestBody} createPublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublishedItemComment: async (
      createPublishedItemCommentRequestBody: CreatePublishedItemCommentRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'createPublishedItemCommentRequestBody' is not null or undefined
      assertParamExists(
        "createPublishedItemComment",
        "createPublishedItemCommentRequestBody",
        createPublishedItemCommentRequestBody,
      );
      const localVarPath = `/PublishedItemComment/createPublishedItemComment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createPublishedItemCommentRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {Array<any>} combinedMediaFiles
     * @param {string} numberOfPurchasedMediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem: async (
      combinedMediaFiles: Array<any>,
      numberOfPurchasedMediaFiles: string,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'combinedMediaFiles' is not null or undefined
      assertParamExists("createShopItem", "combinedMediaFiles", combinedMediaFiles);
      // verify required parameter 'numberOfPurchasedMediaFiles' is not null or undefined
      assertParamExists(
        "createShopItem",
        "numberOfPurchasedMediaFiles",
        numberOfPurchasedMediaFiles,
      );
      // verify required parameter 'caption' is not null or undefined
      assertParamExists("createShopItem", "caption", caption);
      // verify required parameter 'hashtags' is not null or undefined
      assertParamExists("createShopItem", "hashtags", hashtags);
      // verify required parameter 'title' is not null or undefined
      assertParamExists("createShopItem", "title", title);
      // verify required parameter 'price' is not null or undefined
      assertParamExists("createShopItem", "price", price);
      // verify required parameter 'scheduledPublicationTimestamp' is not null or undefined
      assertParamExists(
        "createShopItem",
        "scheduledPublicationTimestamp",
        scheduledPublicationTimestamp,
      );
      // verify required parameter 'collaboratorUserIds' is not null or undefined
      assertParamExists("createShopItem", "collaboratorUserIds", collaboratorUserIds);
      const localVarPath = `/shopitem/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (combinedMediaFiles) {
        combinedMediaFiles.forEach((element) => {
          localVarFormParams.append("combinedMediaFiles", element as any);
        });
      }

      if (numberOfPurchasedMediaFiles !== undefined) {
        localVarFormParams.append(
          "numberOfPurchasedMediaFiles",
          numberOfPurchasedMediaFiles as any,
        );
      }

      if (caption !== undefined) {
        localVarFormParams.append("caption", caption as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessage: async (
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteChatMessageRequestBody' is not null or undefined
      assertParamExists(
        "deleteChatMessage",
        "deleteChatMessageRequestBody",
        deleteChatMessageRequestBody,
      );
      const localVarPath = `/chat/deleteChatMessage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteChatMessageRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost: async (
      deletePostRequestBody: DeletePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deletePostRequestBody' is not null or undefined
      assertParamExists("deletePost", "deletePostRequestBody", deletePostRequestBody);
      const localVarPath = `/post/deletePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deletePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeletePublishedItemCommentRequestBody} deletePublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublishedItemComment: async (
      deletePublishedItemCommentRequestBody: DeletePublishedItemCommentRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deletePublishedItemCommentRequestBody' is not null or undefined
      assertParamExists(
        "deletePublishedItemComment",
        "deletePublishedItemCommentRequestBody",
        deletePublishedItemCommentRequestBody,
      );
      const localVarPath = `/PublishedItemComment/deletePublishedItemComment`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deletePublishedItemCommentRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem: async (
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteShopItemRequestBody' is not null or undefined
      assertParamExists(
        "deleteShopItem",
        "deleteShopItemRequestBody",
        deleteShopItemRequestBody,
      );
      const localVarPath = `/shopitem/delete`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteShopItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesChatRoomExistWithUserIds: async (
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'doesChatRoomExistWithUserIdsRequestBody' is not null or undefined
      assertParamExists(
        "doesChatRoomExistWithUserIds",
        "doesChatRoomExistWithUserIdsRequestBody",
        doesChatRoomExistWithUserIdsRequestBody,
      );
      const localVarPath = `/chat/doesChatRoomExistWithUserIds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        doesChatRoomExistWithUserIdsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elevateUserToAdmin: async (
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'elevateUserToAdminRequestBody' is not null or undefined
      assertParamExists(
        "elevateUserToAdmin",
        "elevateUserToAdminRequestBody",
        elevateUserToAdminRequestBody,
      );
      const localVarPath = `/auth/elevateUserToAdmin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        elevateUserToAdminRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser: async (
      followUserRequestBody: FollowUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'followUserRequestBody' is not null or undefined
      assertParamExists("followUser", "followUserRequestBody", followUserRequestBody);
      const localVarPath = `/userInteractions/followUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        followUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomById: async (
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getChatRoomByIdRequestBody' is not null or undefined
      assertParamExists(
        "getChatRoomById",
        "getChatRoomByIdRequestBody",
        getChatRoomByIdRequestBody,
      );
      const localVarPath = `/chat/getChatRoomById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getChatRoomByIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCountOfUnreadNotifications: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/notification/getCountOfUnreadNotifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditCardsStoredByUserId: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/shopitem/getCreditCardsStoredByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFollowerRequests: async (
      body: object,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("getFollowerRequests", "body", body);
      const localVarPath = `/userInteractions/getFollowerRequests`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfAllPublishedItemsRequestBody} getPageOfAllPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfALLPUBLISHEDITEMS: async (
      getPageOfAllPublishedItemsRequestBody: GetPageOfAllPublishedItemsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfAllPublishedItemsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfALLPUBLISHEDITEMS",
        "getPageOfAllPublishedItemsRequestBody",
        getPageOfAllPublishedItemsRequestBody,
      );
      const localVarPath = `/feed/getPageOf_ALL_PUBLISHED_ITEMS`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfAllPublishedItemsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages: async (
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfChatMessagesRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfChatMessages",
        "getPageOfChatMessagesRequestBody",
        getPageOfChatMessagesRequestBody,
      );
      const localVarPath = `/chat/getPageOfChatMessages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfChatMessagesRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatRooms: async (
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfChatRoomsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfChatRooms",
        "getPageOfChatRoomsRequestBody",
        getPageOfChatRoomsRequestBody,
      );
      const localVarPath = `/chat/getPageOfChatRooms`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfChatRoomsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfNotifications: async (
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfNotificationsRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfNotifications",
        "getPageOfNotificationsRequestBody",
        getPageOfNotificationsRequestBody,
      );
      const localVarPath = `/notification/getPageOfNotifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfNotificationsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowedByUserId: async (
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfUsersFollowedByUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfUsersFollowedByUserId",
        "getPageOfUsersFollowedByUserIdRequestBody",
        getPageOfUsersFollowedByUserIdRequestBody,
      );
      const localVarPath = `/user/getPageOfUsersFollowedByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfUsersFollowedByUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowingUserId: async (
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPageOfUsersFollowingUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPageOfUsersFollowingUserId",
        "getPageOfUsersFollowingUserIdRequestBody",
        getPageOfUsersFollowingUserIdRequestBody,
      );
      const localVarPath = `/user/getPageOfUsersFollowingUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPageOfUsersFollowingUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordResetEmail: async (
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPasswordResetEmailRequestBody' is not null or undefined
      assertParamExists(
        "getPasswordResetEmail",
        "getPasswordResetEmailRequestBody",
        getPasswordResetEmailRequestBody,
      );
      const localVarPath = `/auth/getPasswordResetEmail`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPasswordResetEmailRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemsScheduledByUserRequestBody} getPublishedItemsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser: async (
      getPublishedItemsScheduledByUserRequestBody: GetPublishedItemsScheduledByUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemsScheduledByUserRequestBody' is not null or undefined
      assertParamExists(
        "getPostsScheduledByUser",
        "getPublishedItemsScheduledByUserRequestBody",
        getPublishedItemsScheduledByUserRequestBody,
      );
      const localVarPath = `/post/getPostsScheduledByUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemsScheduledByUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemByIdRequestBody} getPublishedItemByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemById: async (
      getPublishedItemByIdRequestBody: GetPublishedItemByIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemByIdRequestBody' is not null or undefined
      assertParamExists(
        "getPublishedItemById",
        "getPublishedItemByIdRequestBody",
        getPublishedItemByIdRequestBody,
      );
      const localVarPath = `/post/getPublishedItemById`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemByIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemsByUserIdRequestBody} getPublishedItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsByUserId: async (
      getPublishedItemsByUserIdRequestBody: GetPublishedItemsByUserIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemsByUserIdRequestBody' is not null or undefined
      assertParamExists(
        "getPublishedItemsByUserId",
        "getPublishedItemsByUserIdRequestBody",
        getPublishedItemsByUserIdRequestBody,
      );
      const localVarPath = `/post/getPublishedItemsByUserId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemsByUserIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemsByUsernameRequestBody} getPublishedItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsByUsername: async (
      getPublishedItemsByUsernameRequestBody: GetPublishedItemsByUsernameRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemsByUsernameRequestBody' is not null or undefined
      assertParamExists(
        "getPublishedItemsByUsername",
        "getPublishedItemsByUsernameRequestBody",
        getPublishedItemsByUsernameRequestBody,
      );
      const localVarPath = `/post/getPublishedItemsByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemsByUsernameRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedHashtagRequestBody} getPublishedItemsFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsFromFollowedHashtag: async (
      getPublishedItemsFromFollowedHashtagRequestBody: GetPublishedItemsFromFollowedHashtagRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemsFromFollowedHashtagRequestBody' is not null or undefined
      assertParamExists(
        "getPublishedItemsFromFollowedHashtag",
        "getPublishedItemsFromFollowedHashtagRequestBody",
        getPublishedItemsFromFollowedHashtagRequestBody,
      );
      const localVarPath = `/feed/getPublishedItemsFromFollowedHashtag`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemsFromFollowedHashtagRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedUsersRequestBody} getPublishedItemsFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsFromFollowedUsers: async (
      getPublishedItemsFromFollowedUsersRequestBody: GetPublishedItemsFromFollowedUsersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getPublishedItemsFromFollowedUsersRequestBody' is not null or undefined
      assertParamExists(
        "getPublishedItemsFromFollowedUsers",
        "getPublishedItemsFromFollowedUsersRequestBody",
        getPublishedItemsFromFollowedUsersRequestBody,
      );
      const localVarPath = `/feed/getPublishedItemsFromFollowedUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getPublishedItemsFromFollowedUsersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetSavedPublishedItemsRequestBody} getSavedPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedPublishedItems: async (
      getSavedPublishedItemsRequestBody: GetSavedPublishedItemsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getSavedPublishedItemsRequestBody' is not null or undefined
      assertParamExists(
        "getSavedPublishedItems",
        "getSavedPublishedItemsRequestBody",
        getSavedPublishedItemsRequestBody,
      );
      const localVarPath = `/post/getSavedPublishedItems`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getSavedPublishedItemsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserContentFeedFilters: async (
      body: object,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("getUserContentFeedFilters", "body", body);
      const localVarPath = `/feed/getUserContentFeedFilters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile: async (
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUserProfileRequestBody' is not null or undefined
      assertParamExists(
        "getUserProfile",
        "getUserProfileRequestBody",
        getUserProfileRequestBody,
      );
      const localVarPath = `/user/GetUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUserProfileRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIds: async (
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUsersByIdsRequestBody' is not null or undefined
      assertParamExists(
        "getUsersByIds",
        "getUsersByIdsRequestBody",
        getUsersByIdsRequestBody,
      );
      const localVarPath = `/user/getUsersByIds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUsersByIdsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByUsernames: async (
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'getUsersByUsernamesRequestBody' is not null or undefined
      assertParamExists(
        "getUsersByUsernames",
        "getUsersByUsernamesRequestBody",
        getUsersByUsernamesRequestBody,
      );
      const localVarPath = `/user/getUsersByUsernames`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        getUsersByUsernamesRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser: async (
      loginUserRequestBody: LoginUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginUserRequestBody' is not null or undefined
      assertParamExists("loginUser", "loginUserRequestBody", loginUserRequestBody);
      const localVarPath = `/auth/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MakeCreditCardPrimaryRequestBody} makeCreditCardPrimaryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeCardPrimary: async (
      makeCreditCardPrimaryRequestBody: MakeCreditCardPrimaryRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'makeCreditCardPrimaryRequestBody' is not null or undefined
      assertParamExists(
        "makeCardPrimary",
        "makeCreditCardPrimaryRequestBody",
        makeCreditCardPrimaryRequestBody,
      );
      const localVarPath = `/shopitem/makeCardPrimary`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        makeCreditCardPrimaryRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {MarkChatRoomAsReadRequestBody} markChatRoomAsReadRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markChatRoomAsRead: async (
      markChatRoomAsReadRequestBody: MarkChatRoomAsReadRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'markChatRoomAsReadRequestBody' is not null or undefined
      assertParamExists(
        "markChatRoomAsRead",
        "markChatRoomAsReadRequestBody",
        markChatRoomAsReadRequestBody,
      );
      const localVarPath = `/chat/markChatRoomAsRead`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        markChatRoomAsReadRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShopItem: async (
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'purchaseShopItemRequestBody' is not null or undefined
      assertParamExists(
        "purchaseShopItem",
        "purchaseShopItemRequestBody",
        purchaseShopItemRequestBody,
      );
      const localVarPath = `/shopitem/purchaseShopItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        purchaseShopItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ReadPageOfCommentsByPublishedItemIdRequestBody} readPageOfCommentsByPublishedItemIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readPageOfCommentsByPublishedItemId: async (
      readPageOfCommentsByPublishedItemIdRequestBody: ReadPageOfCommentsByPublishedItemIdRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'readPageOfCommentsByPublishedItemIdRequestBody' is not null or undefined
      assertParamExists(
        "readPageOfCommentsByPublishedItemId",
        "readPageOfCommentsByPublishedItemIdRequestBody",
        readPageOfCommentsByPublishedItemIdRequestBody,
      );
      const localVarPath = `/PublishedItemComment/readPageOfCommentsByPublishedItemId`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        readPageOfCommentsByPublishedItemIdRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/refresh-access-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser: async (
      registerUserRequestBody: RegisterUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'registerUserRequestBody' is not null or undefined
      assertParamExists(
        "registerUser",
        "registerUserRequestBody",
        registerUserRequestBody,
      );
      const localVarPath = `/auth/register`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        registerUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCreditCard: async (
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeCreditCardRequestBody' is not null or undefined
      assertParamExists(
        "removeCreditCard",
        "removeCreditCardRequestBody",
        removeCreditCardRequestBody,
      );
      const localVarPath = `/shopitem/removeCreditCard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeCreditCardRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserLikeFromPublishedItem: async (
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeUserLikeFromPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "removeUserLikeFromPublishedItem",
        "removeUserLikeFromPublishedItemRequestBody",
        removeUserLikeFromPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/removeUserLikeFromPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeUserLikeFromPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resetPasswordRequestBody' is not null or undefined
      assertParamExists(
        "resetPassword",
        "resetPasswordRequestBody",
        resetPasswordRequestBody,
      );
      const localVarPath = `/auth/resetPassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resetPasswordRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {ResolveFollowRequestRequestBody} resolveFollowRequestRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveFollowRequest: async (
      resolveFollowRequestRequestBody: ResolveFollowRequestRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'resolveFollowRequestRequestBody' is not null or undefined
      assertParamExists(
        "resolveFollowRequest",
        "resolveFollowRequestRequestBody",
        resolveFollowRequestRequestBody,
      );
      const localVarPath = `/userInteractions/resolveFollowRequest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        resolveFollowRequestRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForHashtags: async (
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForHashtagsRequestBody' is not null or undefined
      assertParamExists(
        "searchForHashtags",
        "searchForHashtagsRequestBody",
        searchForHashtagsRequestBody,
      );
      const localVarPath = `/discover/searchForHashtags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForHashtagsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForPosts: async (
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForPostsRequestBody' is not null or undefined
      assertParamExists(
        "searchForPosts",
        "searchForPostsRequestBody",
        searchForPostsRequestBody,
      );
      const localVarPath = `/discover/searchForPosts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForPostsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForUsers: async (
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchForUsersRequestBody' is not null or undefined
      assertParamExists(
        "searchForUsers",
        "searchForUsersRequestBody",
        searchForUsersRequestBody,
      );
      const localVarPath = `/discover/searchForUsers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchForUsersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername: async (
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'searchUserProfilesByUsernameRequestBody' is not null or undefined
      assertParamExists(
        "searchUserProfilesByUsername",
        "searchUserProfilesByUsernameRequestBody",
        searchUserProfilesByUsernameRequestBody,
      );
      const localVarPath = `/user/SearchUserProfilesByUsername`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        searchUserProfilesByUsernameRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataTypesToFrontend1: async (
      inlineObject5: InlineObject5,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject5' is not null or undefined
      assertParamExists("sendDataTypesToFrontend1", "inlineObject5", inlineObject5);
      const localVarPath = `/utilities/sendDataTypesToFrontend1`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject5,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserContentFeedFilters: async (
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUserContentFeedFiltersRequestBody' is not null or undefined
      assertParamExists(
        "setUserContentFeedFilters",
        "setUserContentFeedFiltersRequestBody",
        setUserContentFeedFiltersRequestBody,
      );
      const localVarPath = `/feed/setUserContentFeedFilters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserContentFeedFiltersRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserHashtags: async (
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'setUserHashtagsRequestBody' is not null or undefined
      assertParamExists(
        "setUserHashtags",
        "setUserHashtagsRequestBody",
        setUserHashtagsRequestBody,
      );
      const localVarPath = `/user/SetUserHashtags`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setUserHashtagsRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sharePost: async (
      sharePostRequestBody: SharePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'sharePostRequestBody' is not null or undefined
      assertParamExists("sharePost", "sharePostRequestBody", sharePostRequestBody);
      const localVarPath = `/post/sharePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        sharePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {StoreCreditCardRequestBody} storeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCreditCard: async (
      storeCreditCardRequestBody: StoreCreditCardRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'storeCreditCardRequestBody' is not null or undefined
      assertParamExists(
        "storeCreditCard",
        "storeCreditCardRequestBody",
        storeCreditCardRequestBody,
      );
      const localVarPath = `/shopitem/storeCreditCard`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        storeCreditCardRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser: async (
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'unfollowUserRequestBody' is not null or undefined
      assertParamExists(
        "unfollowUser",
        "unfollowUserRequestBody",
        unfollowUserRequestBody,
      );
      const localVarPath = `/userInteractions/unfollowUser`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        unfollowUserRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword: async (
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePasswordRequestBody' is not null or undefined
      assertParamExists(
        "updatePassword",
        "updatePasswordRequestBody",
        updatePasswordRequestBody,
      );
      const localVarPath = `/auth/updatePassword`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePasswordRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost: async (
      updatePostRequestBody: UpdatePostRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updatePostRequestBody' is not null or undefined
      assertParamExists("updatePost", "updatePostRequestBody", updatePostRequestBody);
      const localVarPath = `/post/updatePost`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updatePostRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem: async (
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'publishedItemId' is not null or undefined
      assertParamExists("updateShopItem", "publishedItemId", publishedItemId);
      const localVarPath = `/shopitem/update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (publishedItemId !== undefined) {
        localVarFormParams.append("publishedItemId", publishedItemId as any);
      }

      if (description !== undefined) {
        localVarFormParams.append("description", description as any);
      }

      if (hashtags !== undefined) {
        localVarFormParams.append("hashtags", hashtags as any);
      }

      if (title !== undefined) {
        localVarFormParams.append("title", title as any);
      }

      if (price !== undefined) {
        localVarFormParams.append("price", price as any);
      }

      if (scheduledPublicationTimestamp !== undefined) {
        localVarFormParams.append(
          "scheduledPublicationTimestamp",
          scheduledPublicationTimestamp as any,
        );
      }

      if (expirationTimestamp !== undefined) {
        localVarFormParams.append("expirationTimestamp", expirationTimestamp as any);
      }

      if (collaboratorUserIds !== undefined) {
        localVarFormParams.append("collaboratorUserIds", collaboratorUserIds as any);
      }
      if (mediaFiles) {
        mediaFiles.forEach((element) => {
          localVarFormParams.append("mediaFiles", element as any);
        });
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage: async (
      backgroundImage: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'backgroundImage' is not null or undefined
      assertParamExists("updateUserBackgroundImage", "backgroundImage", backgroundImage);
      const localVarPath = `/user/UpdateUserBackgroundImage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (backgroundImage !== undefined) {
        localVarFormParams.append("backgroundImage", backgroundImage as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile: async (
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateUserProfileRequestBody' is not null or undefined
      assertParamExists(
        "updateUserProfile",
        "updateUserProfileRequestBody",
        updateUserProfileRequestBody,
      );
      const localVarPath = `/user/UpdateUserProfile`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserProfileRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture: async (
      profilePicture: any,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'profilePicture' is not null or undefined
      assertParamExists("updateUserProfilePicture", "profilePicture", profilePicture);
      const localVarPath = `/user/UpdateUserProfilePicture`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) ||
        FormData)();

      if (profilePicture !== undefined) {
        localVarFormParams.append("profilePicture", profilePicture as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLikesPublishedItem: async (
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userLikesPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userLikesPublishedItem",
        "userLikesPublishedItemRequestBody",
        userLikesPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userLikesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userLikesPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSavesPublishedItem: async (
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userSavesPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userSavesPublishedItem",
        "userSavesPublishedItemRequestBody",
        userSavesPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userSavesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userSavesPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUnsavesPublishedItem: async (
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'removeUserLikeFromPublishedItemRequestBody' is not null or undefined
      assertParamExists(
        "userUnsavesPublishedItem",
        "removeUserLikeFromPublishedItemRequestBody",
        removeUserLikeFromPublishedItemRequestBody,
      );
      const localVarPath = `/publishedItemInteractions/userUnsavesPublishedItem`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        removeUserLikeFromPublishedItemRequestBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkResetPasswordTokenValidity(
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherCheckResetPasswordTokenValidityFailedReasonCheckResetPasswordTokenValiditySuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.checkResetPasswordTokenValidity(
          checkResetPasswordTokenValidityRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrCreateChatMessageFailedReasonCreateChatMessageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createChatMessage(
        createChatMessageRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createChatMessageInNewChatRoom(
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrCreateChatMessageInNewChatRoomFailedReasonCreateChatMessageInNewChatRoomSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createChatMessageInNewChatRoom(
          createChatMessageInNewRoomRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrCreatePostFailedReasonCreatePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {CreatePublishedItemCommentRequestBody} createPublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPublishedItemComment(
      createPublishedItemCommentRequestBody: CreatePublishedItemCommentRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrCreatePublishedItemCommentFailedReasonCreatePublishedItemCommentSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createPublishedItemComment(
          createPublishedItemCommentRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {Array<any>} combinedMediaFiles
     * @param {string} numberOfPurchasedMediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createShopItem(
      combinedMediaFiles: Array<any>,
      numberOfPurchasedMediaFiles: string,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrCreateShopItemFailedReasonCreateShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createShopItem(
        combinedMediaFiles,
        numberOfPurchasedMediaFiles,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        expirationTimestamp,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteChatMessage(
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrDeleteChatMessageFailedReasonDeleteChatMessageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteChatMessage(
        deleteChatMessageRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherDeletePostFailedDeletePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePost(
        deletePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeletePublishedItemCommentRequestBody} deletePublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePublishedItemComment(
      deletePublishedItemCommentRequestBody: DeletePublishedItemCommentRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrDeletePublishedItemCommentFailedReasonDeletePublishedItemCommentSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePublishedItemComment(
          deletePublishedItemCommentRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherDeleteShopItemFailedDeleteShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShopItem(
        deleteShopItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async doesChatRoomExistWithUserIds(
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrDoesChatRoomExistWithUserIdsFailedReasonDoesChatRoomExistWithUserIdsSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.doesChatRoomExistWithUserIds(
          doesChatRoomExistWithUserIdsRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async elevateUserToAdmin(
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrElevateUserToAdminFailedElevateUserToAdminSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.elevateUserToAdmin(
        elevateUserToAdminRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async followUser(
      followUserRequestBody: FollowUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherFollowUserFailedFollowUserSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(
        followUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getChatRoomById(
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetChatRoomByIdFailedReasonGetChatRoomByIdSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getChatRoomById(
        getChatRoomByIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCountOfUnreadNotifications(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetCountOfUnreadNotificationsFailedReasonGetCountOfUnreadNotificationsSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCountOfUnreadNotifications(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCreditCardsStoredByUserId(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetCreditCardsStoredByUserIdFailedReasonGetCreditCardsStoredByUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getCreditCardsStoredByUserId(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFollowerRequests(
      body: object,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherGetFollowerRequestsFailedGetFollowerRequestsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowerRequests(
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfAllPublishedItemsRequestBody} getPageOfAllPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfALLPUBLISHEDITEMS(
      getPageOfAllPublishedItemsRequestBody: GetPageOfAllPublishedItemsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfAllPublishedItemsFailedReasonGetPageOfAllPublishedItemsSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfALLPUBLISHEDITEMS(
          getPageOfAllPublishedItemsRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfChatMessagesFailedReasonGetPageOfChatMessagesSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfChatMessages(
        getPageOfChatMessagesRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfChatRooms(
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfChatRoomsFailedReasonGetPageOfChatRoomsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfChatRooms(
        getPageOfChatRoomsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfNotifications(
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfNotificationsFailedReasonGetPageOfNotificationsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPageOfNotifications(
        getPageOfNotificationsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfUsersFollowedByUserId(
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfUsersFollowedByUserIdFailedReasonGetPageOfUsersFollowedByUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfUsersFollowedByUserId(
          getPageOfUsersFollowedByUserIdRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPageOfUsersFollowingUserId(
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfUsersFollowingUserIdFailedReasonGetPageOfUsersFollowingUserIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPageOfUsersFollowingUserId(
          getPageOfUsersFollowingUserIdRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPasswordResetEmail(
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPasswordResetEmailFailedGetPasswordResetEmailSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordResetEmail(
        getPasswordResetEmailRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemsScheduledByUserRequestBody} getPublishedItemsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPostsScheduledByUser(
      getPublishedItemsScheduledByUserRequestBody: GetPublishedItemsScheduledByUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherGetPublishedItemsScheduledByUserFailedGetPublishedItemsScheduledByUserSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPostsScheduledByUser(
        getPublishedItemsScheduledByUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemByIdRequestBody} getPublishedItemByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublishedItemById(
      getPublishedItemByIdRequestBody: GetPublishedItemByIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemByIdFailedReasonGetPublishedItemByIdSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedItemById(
        getPublishedItemByIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemsByUserIdRequestBody} getPublishedItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublishedItemsByUserId(
      getPublishedItemsByUserIdRequestBody: GetPublishedItemsByUserIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsByUsernameFailedReasonGetPublishedItemsByUsernameSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedItemsByUserId(
        getPublishedItemsByUserIdRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemsByUsernameRequestBody} getPublishedItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublishedItemsByUsername(
      getPublishedItemsByUsernameRequestBody: GetPublishedItemsByUsernameRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsByUsernameFailedReasonGetPublishedItemsByUsernameSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPublishedItemsByUsername(
          getPublishedItemsByUsernameRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedHashtagRequestBody} getPublishedItemsFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublishedItemsFromFollowedHashtag(
      getPublishedItemsFromFollowedHashtagRequestBody: GetPublishedItemsFromFollowedHashtagRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedHashtagFailedReasonGetPublishedItemsFromFollowedHashtagSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPublishedItemsFromFollowedHashtag(
          getPublishedItemsFromFollowedHashtagRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedUsersRequestBody} getPublishedItemsFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublishedItemsFromFollowedUsers(
      getPublishedItemsFromFollowedUsersRequestBody: GetPublishedItemsFromFollowedUsersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedUsersFailedReasonGetPublishedItemsFromFollowedUsersSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPublishedItemsFromFollowedUsers(
          getPublishedItemsFromFollowedUsersRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetSavedPublishedItemsRequestBody} getSavedPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSavedPublishedItems(
      getSavedPublishedItemsRequestBody: GetSavedPublishedItemsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetSavedPublishedItemsFailedReasonGetSavedPublishedItemsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSavedPublishedItems(
        getSavedPublishedItemsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserContentFeedFilters(
      body: object,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetUserContentFeedFiltersFailedReasonGetUserContentFeedFiltersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserContentFeedFilters(
        body,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserProfile(
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetUserProfileFailedReasonGetUserProfileSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserProfile(
        getUserProfileRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersByIds(
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetUsersByIdsFailedReasonGetUsersByIdsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByIds(
        getUsersByIdsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersByUsernames(
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrGetUsersByUsernamesFailedReasonGetUsersByUsernamesSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByUsernames(
        getUsersByUsernamesRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginUser(
      loginUserRequestBody: LoginUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrAuthFailedReasonAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(
        loginUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {MakeCreditCardPrimaryRequestBody} makeCreditCardPrimaryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeCardPrimary(
      makeCreditCardPrimaryRequestBody: MakeCreditCardPrimaryRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrMakeCreditCardPrimaryFailedReasonMakeCreditCardPrimarySuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.makeCardPrimary(
        makeCreditCardPrimaryRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {MarkChatRoomAsReadRequestBody} markChatRoomAsReadRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async markChatRoomAsRead(
      markChatRoomAsReadRequestBody: MarkChatRoomAsReadRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrMarkChatRoomAsReadFailedReasonMarkChatRoomAsReadSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.markChatRoomAsRead(
        markChatRoomAsReadRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchaseShopItem(
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrPurchaseShopItemFailedReasonPurchaseShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchaseShopItem(
        purchaseShopItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ReadPageOfCommentsByPublishedItemIdRequestBody} readPageOfCommentsByPublishedItemIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async readPageOfCommentsByPublishedItemId(
      readPageOfCommentsByPublishedItemIdRequestBody: ReadPageOfCommentsByPublishedItemIdRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrReadPageOfCommentsByPublishedItemIdFailedReasonReadPageOfCommentsByPublishedItemIdSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.readPageOfCommentsByPublishedItemId(
          readPageOfCommentsByPublishedItemIdRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshAccessToken(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherAuthFailedReasonAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshAccessToken(
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerUser(
      registerUserRequestBody: RegisterUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrRegisterUserFailedReasonAuthSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(
        registerUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCreditCard(
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrRemoveCreditCardFailedReasonRemoveCreditCardSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeCreditCard(
        removeCreditCardRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUserLikeFromPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.removeUserLikeFromPublishedItem(
          removeUserLikeFromPublishedItemRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrResetPasswordFailedReasonResetPasswordSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(
        resetPasswordRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {ResolveFollowRequestRequestBody} resolveFollowRequestRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resolveFollowRequest(
      resolveFollowRequestRequestBody: ResolveFollowRequestRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherResolveFollowRequestFailedResolveFollowRequestSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resolveFollowRequest(
        resolveFollowRequestRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForHashtags(
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSearchForHashtagsFailedReasonSearchForHashtagsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForHashtags(
        searchForHashtagsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForPosts(
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSearchForPostsFailedReasonSearchForPostsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForPosts(
        searchForPostsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchForUsers(
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSearchForUsersFailedReasonSearchForUsersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.searchForUsers(
        searchForUsersRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchUserProfilesByUsername(
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSearchUserProfilesByUsernameFailedReasonSearchUserProfilesByUsernameSuccess>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.searchUserProfilesByUsername(
          searchUserProfilesByUsernameRequestBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sendDataTypesToFrontend1(
      inlineObject5: InlineObject5,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sendDataTypesToFrontend1(
        inlineObject5,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserContentFeedFilters(
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserContentFeedFilters(
        setUserContentFeedFiltersRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setUserHashtags(
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherSetUserHashtagsFailedSetUserHashtagsSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setUserHashtags(
        setUserHashtagsRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async sharePost(
      sharePostRequestBody: SharePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrSharePostFailedReasonSharePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.sharePost(
        sharePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {StoreCreditCardRequestBody} storeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeCreditCard(
      storeCreditCardRequestBody: StoreCreditCardRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrStoreCreditCardFailedReasonStoreCreditCardSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeCreditCard(
        storeCreditCardRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unfollowUser(
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(
        unfollowUserRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePassword(
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdatePasswordFailedUpdatePasswordSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(
        updatePasswordRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePost(
      updatePostRequestBody: UpdatePostRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdatePostFailedReasonUpdatePostSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePost(
        updatePostRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateShopItem(
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdateShopItemFailedReasonUpdateShopItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateShopItem(
        publishedItemId,
        description,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserBackgroundImageFailedReasonUpdateUserBackgroundImageSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserBackgroundImage(
        backgroundImage,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfile(
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserProfileFailedReasonUpdateUserProfileSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfile(
        updateUserProfileRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserProfilePictureFailedReasonUpdateUserProfilePictureSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserProfilePicture(
        profilePicture,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userLikesPublishedItem(
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherUserLikesPublishedItemFailedUserLikesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userLikesPublishedItem(
        userLikesPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userSavesPublishedItem(
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherUserSavesPublishedItemFailedUserSavesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userSavesPublishedItem(
        userSavesPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userUnsavesPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<EitherUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userUnsavesPublishedItem(
        removeUserLikeFromPublishedItemRequestBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     *
     * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkResetPasswordTokenValidity(
      checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
      options?: any,
    ): AxiosPromise<EitherCheckResetPasswordTokenValidityFailedReasonCheckResetPasswordTokenValiditySuccess> {
      return localVarFp
        .checkResetPasswordTokenValidity(
          checkResetPasswordTokenValidityRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessage(
      createChatMessageRequestBody: CreateChatMessageRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrCreateChatMessageFailedReasonCreateChatMessageSuccess> {
      return localVarFp
        .createChatMessage(createChatMessageRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createChatMessageInNewChatRoom(
      createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrCreateChatMessageInNewChatRoomFailedReasonCreateChatMessageInNewChatRoomSuccess> {
      return localVarFp
        .createChatMessageInNewChatRoom(createChatMessageInNewRoomRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<any>} mediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPost(
      mediaFiles: Array<any>,
      caption: string,
      hashtags: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrCreatePostFailedReasonCreatePostSuccess> {
      return localVarFp
        .createPost(
          mediaFiles,
          caption,
          hashtags,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {CreatePublishedItemCommentRequestBody} createPublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPublishedItemComment(
      createPublishedItemCommentRequestBody: CreatePublishedItemCommentRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrCreatePublishedItemCommentFailedReasonCreatePublishedItemCommentSuccess> {
      return localVarFp
        .createPublishedItemComment(createPublishedItemCommentRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {Array<any>} combinedMediaFiles
     * @param {string} numberOfPurchasedMediaFiles
     * @param {string} caption
     * @param {string} hashtags
     * @param {string} title
     * @param {string} price
     * @param {string} scheduledPublicationTimestamp
     * @param {string} collaboratorUserIds
     * @param {string} [expirationTimestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createShopItem(
      combinedMediaFiles: Array<any>,
      numberOfPurchasedMediaFiles: string,
      caption: string,
      hashtags: string,
      title: string,
      price: string,
      scheduledPublicationTimestamp: string,
      collaboratorUserIds: string,
      expirationTimestamp?: string,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrCreateShopItemFailedReasonCreateShopItemSuccess> {
      return localVarFp
        .createShopItem(
          combinedMediaFiles,
          numberOfPurchasedMediaFiles,
          caption,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          collaboratorUserIds,
          expirationTimestamp,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteChatMessage(
      deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrDeleteChatMessageFailedReasonDeleteChatMessageSuccess> {
      return localVarFp
        .deleteChatMessage(deleteChatMessageRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeletePostRequestBody} deletePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePost(
      deletePostRequestBody: DeletePostRequestBody,
      options?: any,
    ): AxiosPromise<EitherDeletePostFailedDeletePostSuccess> {
      return localVarFp
        .deletePost(deletePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeletePublishedItemCommentRequestBody} deletePublishedItemCommentRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublishedItemComment(
      deletePublishedItemCommentRequestBody: DeletePublishedItemCommentRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrDeletePublishedItemCommentFailedReasonDeletePublishedItemCommentSuccess> {
      return localVarFp
        .deletePublishedItemComment(deletePublishedItemCommentRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteShopItem(
      deleteShopItemRequestBody: DeleteShopItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherDeleteShopItemFailedDeleteShopItemSuccess> {
      return localVarFp
        .deleteShopItem(deleteShopItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    doesChatRoomExistWithUserIds(
      doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrDoesChatRoomExistWithUserIdsFailedReasonDoesChatRoomExistWithUserIdsSuccess> {
      return localVarFp
        .doesChatRoomExistWithUserIds(doesChatRoomExistWithUserIdsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    elevateUserToAdmin(
      elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrElevateUserToAdminFailedElevateUserToAdminSuccess> {
      return localVarFp
        .elevateUserToAdmin(elevateUserToAdminRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {FollowUserRequestBody} followUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    followUser(
      followUserRequestBody: FollowUserRequestBody,
      options?: any,
    ): AxiosPromise<EitherFollowUserFailedFollowUserSuccess> {
      return localVarFp
        .followUser(followUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getChatRoomById(
      getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetChatRoomByIdFailedReasonGetChatRoomByIdSuccess> {
      return localVarFp
        .getChatRoomById(getChatRoomByIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCountOfUnreadNotifications(
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetCountOfUnreadNotificationsFailedReasonGetCountOfUnreadNotificationsSuccess> {
      return localVarFp
        .getCountOfUnreadNotifications(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCreditCardsStoredByUserId(
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetCreditCardsStoredByUserIdFailedReasonGetCreditCardsStoredByUserIdSuccess> {
      return localVarFp
        .getCreditCardsStoredByUserId(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFollowerRequests(
      body: object,
      options?: any,
    ): AxiosPromise<EitherGetFollowerRequestsFailedGetFollowerRequestsSuccess> {
      return localVarFp
        .getFollowerRequests(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfAllPublishedItemsRequestBody} getPageOfAllPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfALLPUBLISHEDITEMS(
      getPageOfAllPublishedItemsRequestBody: GetPageOfAllPublishedItemsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfAllPublishedItemsFailedReasonGetPageOfAllPublishedItemsSuccess> {
      return localVarFp
        .getPageOfALLPUBLISHEDITEMS(getPageOfAllPublishedItemsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatMessages(
      getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfChatMessagesFailedReasonGetPageOfChatMessagesSuccess> {
      return localVarFp
        .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfChatRooms(
      getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfChatRoomsFailedReasonGetPageOfChatRoomsSuccess> {
      return localVarFp
        .getPageOfChatRooms(getPageOfChatRoomsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfNotifications(
      getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfNotificationsFailedReasonGetPageOfNotificationsSuccess> {
      return localVarFp
        .getPageOfNotifications(getPageOfNotificationsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowedByUserId(
      getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfUsersFollowedByUserIdFailedReasonGetPageOfUsersFollowedByUserIdSuccess> {
      return localVarFp
        .getPageOfUsersFollowedByUserId(
          getPageOfUsersFollowedByUserIdRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPageOfUsersFollowingUserId(
      getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPageOfUsersFollowingUserIdFailedReasonGetPageOfUsersFollowingUserIdSuccess> {
      return localVarFp
        .getPageOfUsersFollowingUserId(getPageOfUsersFollowingUserIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordResetEmail(
      getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPasswordResetEmailFailedGetPasswordResetEmailSuccess> {
      return localVarFp
        .getPasswordResetEmail(getPasswordResetEmailRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemsScheduledByUserRequestBody} getPublishedItemsScheduledByUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPostsScheduledByUser(
      getPublishedItemsScheduledByUserRequestBody: GetPublishedItemsScheduledByUserRequestBody,
      options?: any,
    ): AxiosPromise<EitherGetPublishedItemsScheduledByUserFailedGetPublishedItemsScheduledByUserSuccess> {
      return localVarFp
        .getPostsScheduledByUser(getPublishedItemsScheduledByUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemByIdRequestBody} getPublishedItemByIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemById(
      getPublishedItemByIdRequestBody: GetPublishedItemByIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemByIdFailedReasonGetPublishedItemByIdSuccess> {
      return localVarFp
        .getPublishedItemById(getPublishedItemByIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemsByUserIdRequestBody} getPublishedItemsByUserIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsByUserId(
      getPublishedItemsByUserIdRequestBody: GetPublishedItemsByUserIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsByUsernameFailedReasonGetPublishedItemsByUsernameSuccess> {
      return localVarFp
        .getPublishedItemsByUserId(getPublishedItemsByUserIdRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemsByUsernameRequestBody} getPublishedItemsByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsByUsername(
      getPublishedItemsByUsernameRequestBody: GetPublishedItemsByUsernameRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsByUsernameFailedReasonGetPublishedItemsByUsernameSuccess> {
      return localVarFp
        .getPublishedItemsByUsername(getPublishedItemsByUsernameRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedHashtagRequestBody} getPublishedItemsFromFollowedHashtagRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsFromFollowedHashtag(
      getPublishedItemsFromFollowedHashtagRequestBody: GetPublishedItemsFromFollowedHashtagRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedHashtagFailedReasonGetPublishedItemsFromFollowedHashtagSuccess> {
      return localVarFp
        .getPublishedItemsFromFollowedHashtag(
          getPublishedItemsFromFollowedHashtagRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetPublishedItemsFromFollowedUsersRequestBody} getPublishedItemsFromFollowedUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublishedItemsFromFollowedUsers(
      getPublishedItemsFromFollowedUsersRequestBody: GetPublishedItemsFromFollowedUsersRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetPublishedItemsFromFollowedUsersFailedReasonGetPublishedItemsFromFollowedUsersSuccess> {
      return localVarFp
        .getPublishedItemsFromFollowedUsers(
          getPublishedItemsFromFollowedUsersRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetSavedPublishedItemsRequestBody} getSavedPublishedItemsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSavedPublishedItems(
      getSavedPublishedItemsRequestBody: GetSavedPublishedItemsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetSavedPublishedItemsFailedReasonGetSavedPublishedItemsSuccess> {
      return localVarFp
        .getSavedPublishedItems(getSavedPublishedItemsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserContentFeedFilters(
      body: object,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetUserContentFeedFiltersFailedReasonGetUserContentFeedFiltersSuccess> {
      return localVarFp
        .getUserContentFeedFilters(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUserProfileRequestBody} getUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(
      getUserProfileRequestBody: GetUserProfileRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetUserProfileFailedReasonGetUserProfileSuccess> {
      return localVarFp
        .getUserProfile(getUserProfileRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByIds(
      getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetUsersByIdsFailedReasonGetUsersByIdsSuccess> {
      return localVarFp
        .getUsersByIds(getUsersByIdsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersByUsernames(
      getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrGetUsersByUsernamesFailedReasonGetUsersByUsernamesSuccess> {
      return localVarFp
        .getUsersByUsernames(getUsersByUsernamesRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {LoginUserRequestBody} loginUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginUser(
      loginUserRequestBody: LoginUserRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrAuthFailedReasonAuthSuccess> {
      return localVarFp
        .loginUser(loginUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {MakeCreditCardPrimaryRequestBody} makeCreditCardPrimaryRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeCardPrimary(
      makeCreditCardPrimaryRequestBody: MakeCreditCardPrimaryRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrMakeCreditCardPrimaryFailedReasonMakeCreditCardPrimarySuccess> {
      return localVarFp
        .makeCardPrimary(makeCreditCardPrimaryRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {MarkChatRoomAsReadRequestBody} markChatRoomAsReadRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markChatRoomAsRead(
      markChatRoomAsReadRequestBody: MarkChatRoomAsReadRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrMarkChatRoomAsReadFailedReasonMarkChatRoomAsReadSuccess> {
      return localVarFp
        .markChatRoomAsRead(markChatRoomAsReadRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchaseShopItem(
      purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrPurchaseShopItemFailedReasonPurchaseShopItemSuccess> {
      return localVarFp
        .purchaseShopItem(purchaseShopItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ReadPageOfCommentsByPublishedItemIdRequestBody} readPageOfCommentsByPublishedItemIdRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readPageOfCommentsByPublishedItemId(
      readPageOfCommentsByPublishedItemIdRequestBody: ReadPageOfCommentsByPublishedItemIdRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrReadPageOfCommentsByPublishedItemIdFailedReasonReadPageOfCommentsByPublishedItemIdSuccess> {
      return localVarFp
        .readPageOfCommentsByPublishedItemId(
          readPageOfCommentsByPublishedItemIdRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshAccessToken(options?: any): AxiosPromise<EitherAuthFailedReasonAuthSuccess> {
      return localVarFp
        .refreshAccessToken(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RegisterUserRequestBody} registerUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      registerUserRequestBody: RegisterUserRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrRegisterUserFailedReasonAuthSuccess> {
      return localVarFp
        .registerUser(registerUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCreditCard(
      removeCreditCardRequestBody: RemoveCreditCardRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrRemoveCreditCardFailedReasonRemoveCreditCardSuccess> {
      return localVarFp
        .removeCreditCard(removeCreditCardRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUserLikeFromPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherFailedToRemoveUserLikeFromPublishedItemResponseSuccessfullyRemovedUserLikeFromPostResponse> {
      return localVarFp
        .removeUserLikeFromPublishedItem(
          removeUserLikeFromPublishedItemRequestBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ResetPasswordRequestBody} resetPasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(
      resetPasswordRequestBody: ResetPasswordRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrResetPasswordFailedReasonResetPasswordSuccess> {
      return localVarFp
        .resetPassword(resetPasswordRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {ResolveFollowRequestRequestBody} resolveFollowRequestRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveFollowRequest(
      resolveFollowRequestRequestBody: ResolveFollowRequestRequestBody,
      options?: any,
    ): AxiosPromise<EitherResolveFollowRequestFailedResolveFollowRequestSuccess> {
      return localVarFp
        .resolveFollowRequest(resolveFollowRequestRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForHashtags(
      searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSearchForHashtagsFailedReasonSearchForHashtagsSuccess> {
      return localVarFp
        .searchForHashtags(searchForHashtagsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForPostsRequestBody} searchForPostsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForPosts(
      searchForPostsRequestBody: SearchForPostsRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSearchForPostsFailedReasonSearchForPostsSuccess> {
      return localVarFp
        .searchForPosts(searchForPostsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchForUsersRequestBody} searchForUsersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchForUsers(
      searchForUsersRequestBody: SearchForUsersRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSearchForUsersFailedReasonSearchForUsersSuccess> {
      return localVarFp
        .searchForUsers(searchForUsersRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchUserProfilesByUsername(
      searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSearchUserProfilesByUsernameFailedReasonSearchUserProfilesByUsernameSuccess> {
      return localVarFp
        .searchUserProfilesByUsername(searchUserProfilesByUsernameRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject5} inlineObject5
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendDataTypesToFrontend1(
      inlineObject5: InlineObject5,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .sendDataTypesToFrontend1(inlineObject5, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserContentFeedFilters(
      setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSetUserContentFeedFiltersFailedSetUserContentFeedFiltersSuccess> {
      return localVarFp
        .setUserContentFeedFilters(setUserContentFeedFiltersRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setUserHashtags(
      setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
      options?: any,
    ): AxiosPromise<EitherSetUserHashtagsFailedSetUserHashtagsSuccess> {
      return localVarFp
        .setUserHashtags(setUserHashtagsRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {SharePostRequestBody} sharePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sharePost(
      sharePostRequestBody: SharePostRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrSharePostFailedReasonSharePostSuccess> {
      return localVarFp
        .sharePost(sharePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {StoreCreditCardRequestBody} storeCreditCardRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeCreditCard(
      storeCreditCardRequestBody: StoreCreditCardRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrStoreCreditCardFailedReasonStoreCreditCardSuccess> {
      return localVarFp
        .storeCreditCard(storeCreditCardRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UnfollowUserRequestBody} unfollowUserRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unfollowUser(
      unfollowUserRequestBody: UnfollowUserRequestBody,
      options?: any,
    ): AxiosPromise<EitherFailedToUnfollowUserProfileResponseSuccessfullyUnfollowedUserProfileResponse> {
      return localVarFp
        .unfollowUser(unfollowUserRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePassword(
      updatePasswordRequestBody: UpdatePasswordRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdatePasswordFailedUpdatePasswordSuccess> {
      return localVarFp
        .updatePassword(updatePasswordRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdatePostRequestBody} updatePostRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePost(
      updatePostRequestBody: UpdatePostRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdatePostFailedReasonUpdatePostSuccess> {
      return localVarFp
        .updatePost(updatePostRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} publishedItemId
     * @param {string} [description]
     * @param {string} [hashtags]
     * @param {string} [title]
     * @param {string} [price]
     * @param {string} [scheduledPublicationTimestamp]
     * @param {string} [expirationTimestamp]
     * @param {string} [collaboratorUserIds]
     * @param {Array<any>} [mediaFiles]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateShopItem(
      publishedItemId: string,
      description?: string,
      hashtags?: string,
      title?: string,
      price?: string,
      scheduledPublicationTimestamp?: string,
      expirationTimestamp?: string,
      collaboratorUserIds?: string,
      mediaFiles?: Array<any>,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdateShopItemFailedReasonUpdateShopItemSuccess> {
      return localVarFp
        .updateShopItem(
          publishedItemId,
          description,
          hashtags,
          title,
          price,
          scheduledPublicationTimestamp,
          expirationTimestamp,
          collaboratorUserIds,
          mediaFiles,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} backgroundImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserBackgroundImage(
      backgroundImage: any,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserBackgroundImageFailedReasonUpdateUserBackgroundImageSuccess> {
      return localVarFp
        .updateUserBackgroundImage(backgroundImage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfile(
      updateUserProfileRequestBody: UpdateUserProfileRequestBody,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserProfileFailedReasonUpdateUserProfileSuccess> {
      return localVarFp
        .updateUserProfile(updateUserProfileRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {any} profilePicture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserProfilePicture(
      profilePicture: any,
      options?: any,
    ): AxiosPromise<EitherErrorReasonTypesStringOrUpdateUserProfilePictureFailedReasonUpdateUserProfilePictureSuccess> {
      return localVarFp
        .updateUserProfilePicture(profilePicture, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userLikesPublishedItem(
      userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherUserLikesPublishedItemFailedUserLikesPublishedItemSuccess> {
      return localVarFp
        .userLikesPublishedItem(userLikesPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSavesPublishedItem(
      userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherUserSavesPublishedItemFailedUserSavesPublishedItemSuccess> {
      return localVarFp
        .userSavesPublishedItem(userSavesPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUnsavesPublishedItem(
      removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
      options?: any,
    ): AxiosPromise<EitherUserUnsavesPublishedItemFailedUserUnsavesPublishedItemSuccess> {
      return localVarFp
        .userUnsavesPublishedItem(removeUserLikeFromPublishedItemRequestBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {CheckResetPasswordTokenValidityRequestBody} checkResetPasswordTokenValidityRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public checkResetPasswordTokenValidity(
    checkResetPasswordTokenValidityRequestBody: CheckResetPasswordTokenValidityRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .checkResetPasswordTokenValidity(
        checkResetPasswordTokenValidityRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateChatMessageRequestBody} createChatMessageRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChatMessage(
    createChatMessageRequestBody: CreateChatMessageRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createChatMessage(createChatMessageRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreateChatMessageInNewRoomRequestBody} createChatMessageInNewRoomRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createChatMessageInNewChatRoom(
    createChatMessageInNewRoomRequestBody: CreateChatMessageInNewRoomRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createChatMessageInNewChatRoom(createChatMessageInNewRoomRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<any>} mediaFiles
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPost(
    mediaFiles: Array<any>,
    caption: string,
    hashtags: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createPost(
        mediaFiles,
        caption,
        hashtags,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {CreatePublishedItemCommentRequestBody} createPublishedItemCommentRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createPublishedItemComment(
    createPublishedItemCommentRequestBody: CreatePublishedItemCommentRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createPublishedItemComment(createPublishedItemCommentRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {Array<any>} combinedMediaFiles
   * @param {string} numberOfPurchasedMediaFiles
   * @param {string} caption
   * @param {string} hashtags
   * @param {string} title
   * @param {string} price
   * @param {string} scheduledPublicationTimestamp
   * @param {string} collaboratorUserIds
   * @param {string} [expirationTimestamp]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createShopItem(
    combinedMediaFiles: Array<any>,
    numberOfPurchasedMediaFiles: string,
    caption: string,
    hashtags: string,
    title: string,
    price: string,
    scheduledPublicationTimestamp: string,
    collaboratorUserIds: string,
    expirationTimestamp?: string,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .createShopItem(
        combinedMediaFiles,
        numberOfPurchasedMediaFiles,
        caption,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        collaboratorUserIds,
        expirationTimestamp,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteChatMessageRequestBody} deleteChatMessageRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteChatMessage(
    deleteChatMessageRequestBody: DeleteChatMessageRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteChatMessage(deleteChatMessageRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeletePostRequestBody} deletePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deletePost(deletePostRequestBody: DeletePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .deletePost(deletePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeletePublishedItemCommentRequestBody} deletePublishedItemCommentRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deletePublishedItemComment(
    deletePublishedItemCommentRequestBody: DeletePublishedItemCommentRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deletePublishedItemComment(deletePublishedItemCommentRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DeleteShopItemRequestBody} deleteShopItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteShopItem(
    deleteShopItemRequestBody: DeleteShopItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .deleteShopItem(deleteShopItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {DoesChatRoomExistWithUserIdsRequestBody} doesChatRoomExistWithUserIdsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public doesChatRoomExistWithUserIds(
    doesChatRoomExistWithUserIdsRequestBody: DoesChatRoomExistWithUserIdsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .doesChatRoomExistWithUserIds(doesChatRoomExistWithUserIdsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ElevateUserToAdminRequestBody} elevateUserToAdminRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public elevateUserToAdmin(
    elevateUserToAdminRequestBody: ElevateUserToAdminRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .elevateUserToAdmin(elevateUserToAdminRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {FollowUserRequestBody} followUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public followUser(followUserRequestBody: FollowUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .followUser(followUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetChatRoomByIdRequestBody} getChatRoomByIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getChatRoomById(
    getChatRoomByIdRequestBody: GetChatRoomByIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getChatRoomById(getChatRoomByIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCountOfUnreadNotifications(options?: any) {
    return DefaultApiFp(this.configuration)
      .getCountOfUnreadNotifications(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getCreditCardsStoredByUserId(options?: any) {
    return DefaultApiFp(this.configuration)
      .getCreditCardsStoredByUserId(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getFollowerRequests(body: object, options?: any) {
    return DefaultApiFp(this.configuration)
      .getFollowerRequests(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfAllPublishedItemsRequestBody} getPageOfAllPublishedItemsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfALLPUBLISHEDITEMS(
    getPageOfAllPublishedItemsRequestBody: GetPageOfAllPublishedItemsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfALLPUBLISHEDITEMS(getPageOfAllPublishedItemsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfChatMessagesRequestBody} getPageOfChatMessagesRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfChatMessages(
    getPageOfChatMessagesRequestBody: GetPageOfChatMessagesRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfChatMessages(getPageOfChatMessagesRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfChatRoomsRequestBody} getPageOfChatRoomsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfChatRooms(
    getPageOfChatRoomsRequestBody: GetPageOfChatRoomsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfChatRooms(getPageOfChatRoomsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfNotificationsRequestBody} getPageOfNotificationsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfNotifications(
    getPageOfNotificationsRequestBody: GetPageOfNotificationsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfNotifications(getPageOfNotificationsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfUsersFollowedByUserIdRequestBody} getPageOfUsersFollowedByUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfUsersFollowedByUserId(
    getPageOfUsersFollowedByUserIdRequestBody: GetPageOfUsersFollowedByUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfUsersFollowedByUserId(getPageOfUsersFollowedByUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPageOfUsersFollowingUserIdRequestBody} getPageOfUsersFollowingUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPageOfUsersFollowingUserId(
    getPageOfUsersFollowingUserIdRequestBody: GetPageOfUsersFollowingUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPageOfUsersFollowingUserId(getPageOfUsersFollowingUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPasswordResetEmailRequestBody} getPasswordResetEmailRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPasswordResetEmail(
    getPasswordResetEmailRequestBody: GetPasswordResetEmailRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPasswordResetEmail(getPasswordResetEmailRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemsScheduledByUserRequestBody} getPublishedItemsScheduledByUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPostsScheduledByUser(
    getPublishedItemsScheduledByUserRequestBody: GetPublishedItemsScheduledByUserRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPostsScheduledByUser(getPublishedItemsScheduledByUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemByIdRequestBody} getPublishedItemByIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPublishedItemById(
    getPublishedItemByIdRequestBody: GetPublishedItemByIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPublishedItemById(getPublishedItemByIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemsByUserIdRequestBody} getPublishedItemsByUserIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPublishedItemsByUserId(
    getPublishedItemsByUserIdRequestBody: GetPublishedItemsByUserIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPublishedItemsByUserId(getPublishedItemsByUserIdRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemsByUsernameRequestBody} getPublishedItemsByUsernameRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPublishedItemsByUsername(
    getPublishedItemsByUsernameRequestBody: GetPublishedItemsByUsernameRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPublishedItemsByUsername(getPublishedItemsByUsernameRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemsFromFollowedHashtagRequestBody} getPublishedItemsFromFollowedHashtagRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPublishedItemsFromFollowedHashtag(
    getPublishedItemsFromFollowedHashtagRequestBody: GetPublishedItemsFromFollowedHashtagRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPublishedItemsFromFollowedHashtag(
        getPublishedItemsFromFollowedHashtagRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetPublishedItemsFromFollowedUsersRequestBody} getPublishedItemsFromFollowedUsersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getPublishedItemsFromFollowedUsers(
    getPublishedItemsFromFollowedUsersRequestBody: GetPublishedItemsFromFollowedUsersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getPublishedItemsFromFollowedUsers(
        getPublishedItemsFromFollowedUsersRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetSavedPublishedItemsRequestBody} getSavedPublishedItemsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getSavedPublishedItems(
    getSavedPublishedItemsRequestBody: GetSavedPublishedItemsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getSavedPublishedItems(getSavedPublishedItemsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserContentFeedFilters(body: object, options?: any) {
    return DefaultApiFp(this.configuration)
      .getUserContentFeedFilters(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUserProfileRequestBody} getUserProfileRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUserProfile(
    getUserProfileRequestBody: GetUserProfileRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUserProfile(getUserProfileRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUsersByIdsRequestBody} getUsersByIdsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsersByIds(
    getUsersByIdsRequestBody: GetUsersByIdsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUsersByIds(getUsersByIdsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {GetUsersByUsernamesRequestBody} getUsersByUsernamesRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getUsersByUsernames(
    getUsersByUsernamesRequestBody: GetUsersByUsernamesRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .getUsersByUsernames(getUsersByUsernamesRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {LoginUserRequestBody} loginUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public loginUser(loginUserRequestBody: LoginUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .loginUser(loginUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public logout(options?: any) {
    return DefaultApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {MakeCreditCardPrimaryRequestBody} makeCreditCardPrimaryRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public makeCardPrimary(
    makeCreditCardPrimaryRequestBody: MakeCreditCardPrimaryRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .makeCardPrimary(makeCreditCardPrimaryRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {MarkChatRoomAsReadRequestBody} markChatRoomAsReadRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public markChatRoomAsRead(
    markChatRoomAsReadRequestBody: MarkChatRoomAsReadRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .markChatRoomAsRead(markChatRoomAsReadRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {PurchaseShopItemRequestBody} purchaseShopItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public purchaseShopItem(
    purchaseShopItemRequestBody: PurchaseShopItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .purchaseShopItem(purchaseShopItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ReadPageOfCommentsByPublishedItemIdRequestBody} readPageOfCommentsByPublishedItemIdRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public readPageOfCommentsByPublishedItemId(
    readPageOfCommentsByPublishedItemIdRequestBody: ReadPageOfCommentsByPublishedItemIdRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .readPageOfCommentsByPublishedItemId(
        readPageOfCommentsByPublishedItemIdRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public refreshAccessToken(options?: any) {
    return DefaultApiFp(this.configuration)
      .refreshAccessToken(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RegisterUserRequestBody} registerUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public registerUser(registerUserRequestBody: RegisterUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .registerUser(registerUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveCreditCardRequestBody} removeCreditCardRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public removeCreditCard(
    removeCreditCardRequestBody: RemoveCreditCardRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .removeCreditCard(removeCreditCardRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public removeUserLikeFromPublishedItem(
    removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .removeUserLikeFromPublishedItem(
        removeUserLikeFromPublishedItemRequestBody,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ResetPasswordRequestBody} resetPasswordRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public resetPassword(
    resetPasswordRequestBody: ResetPasswordRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .resetPassword(resetPasswordRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {ResolveFollowRequestRequestBody} resolveFollowRequestRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public resolveFollowRequest(
    resolveFollowRequestRequestBody: ResolveFollowRequestRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .resolveFollowRequest(resolveFollowRequestRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForHashtagsRequestBody} searchForHashtagsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForHashtags(
    searchForHashtagsRequestBody: SearchForHashtagsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForHashtags(searchForHashtagsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForPostsRequestBody} searchForPostsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForPosts(
    searchForPostsRequestBody: SearchForPostsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForPosts(searchForPostsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchForUsersRequestBody} searchForUsersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchForUsers(
    searchForUsersRequestBody: SearchForUsersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchForUsers(searchForUsersRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SearchUserProfilesByUsernameRequestBody} searchUserProfilesByUsernameRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public searchUserProfilesByUsername(
    searchUserProfilesByUsernameRequestBody: SearchUserProfilesByUsernameRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .searchUserProfilesByUsername(searchUserProfilesByUsernameRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject5} inlineObject5
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sendDataTypesToFrontend1(inlineObject5: InlineObject5, options?: any) {
    return DefaultApiFp(this.configuration)
      .sendDataTypesToFrontend1(inlineObject5, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SetUserContentFeedFiltersRequestBody} setUserContentFeedFiltersRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setUserContentFeedFilters(
    setUserContentFeedFiltersRequestBody: SetUserContentFeedFiltersRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .setUserContentFeedFilters(setUserContentFeedFiltersRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SetUserHashtagsRequestBody} setUserHashtagsRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public setUserHashtags(
    setUserHashtagsRequestBody: SetUserHashtagsRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .setUserHashtags(setUserHashtagsRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {SharePostRequestBody} sharePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public sharePost(sharePostRequestBody: SharePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .sharePost(sharePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {StoreCreditCardRequestBody} storeCreditCardRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public storeCreditCard(
    storeCreditCardRequestBody: StoreCreditCardRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .storeCreditCard(storeCreditCardRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UnfollowUserRequestBody} unfollowUserRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public unfollowUser(unfollowUserRequestBody: UnfollowUserRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .unfollowUser(unfollowUserRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePasswordRequestBody} updatePasswordRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePassword(
    updatePasswordRequestBody: UpdatePasswordRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updatePassword(updatePasswordRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdatePostRequestBody} updatePostRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updatePost(updatePostRequestBody: UpdatePostRequestBody, options?: any) {
    return DefaultApiFp(this.configuration)
      .updatePost(updatePostRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} publishedItemId
   * @param {string} [description]
   * @param {string} [hashtags]
   * @param {string} [title]
   * @param {string} [price]
   * @param {string} [scheduledPublicationTimestamp]
   * @param {string} [expirationTimestamp]
   * @param {string} [collaboratorUserIds]
   * @param {Array<any>} [mediaFiles]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateShopItem(
    publishedItemId: string,
    description?: string,
    hashtags?: string,
    title?: string,
    price?: string,
    scheduledPublicationTimestamp?: string,
    expirationTimestamp?: string,
    collaboratorUserIds?: string,
    mediaFiles?: Array<any>,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateShopItem(
        publishedItemId,
        description,
        hashtags,
        title,
        price,
        scheduledPublicationTimestamp,
        expirationTimestamp,
        collaboratorUserIds,
        mediaFiles,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} backgroundImage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserBackgroundImage(backgroundImage: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserBackgroundImage(backgroundImage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UpdateUserProfileRequestBody} updateUserProfileRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfile(
    updateUserProfileRequestBody: UpdateUserProfileRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .updateUserProfile(updateUserProfileRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {any} profilePicture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateUserProfilePicture(profilePicture: any, options?: any) {
    return DefaultApiFp(this.configuration)
      .updateUserProfilePicture(profilePicture, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserLikesPublishedItemRequestBody} userLikesPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userLikesPublishedItem(
    userLikesPublishedItemRequestBody: UserLikesPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userLikesPublishedItem(userLikesPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {UserSavesPublishedItemRequestBody} userSavesPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userSavesPublishedItem(
    userSavesPublishedItemRequestBody: UserSavesPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userSavesPublishedItem(userSavesPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {RemoveUserLikeFromPublishedItemRequestBody} removeUserLikeFromPublishedItemRequestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public userUnsavesPublishedItem(
    removeUserLikeFromPublishedItemRequestBody: RemoveUserLikeFromPublishedItemRequestBody,
    options?: any,
  ) {
    return DefaultApiFp(this.configuration)
      .userUnsavesPublishedItem(removeUserLikeFromPublishedItemRequestBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
